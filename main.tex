% !TeX spellcheck = de_CH
\documentclass[11pt, a4paper]{article}
\usepackage[margin=2.54cm]{geometry}

% !TeX program = lualatex


% Fonts
\usepackage{fourier-otf}
\usepackage{fontspec}
\setmainfont{Heuristica}  

% Math
\usepackage{amsmath, amsthm, mathrsfs,bm}

\usepackage[ngerman]{babel}
\usepackage{csquotes}

\usepackage{booktabs}
\usepackage{url}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{comment}
\usepackage[dvipsnames]{xcolor}
\usepackage{lipsum} 
\usepackage{mdframed}  
\usepackage[backend=biber]{biblatex}
\addbibresource{refs.bib}
\graphicspath{{image}}
\usepackage{setspace}
\usepackage{parskip}
\onehalfspacing

\usepackage{nameref}
\usepackage[]{hyperref}
\usepackage[acronym, nomain]{glossaries}
\usepackage{chngcntr}

\usepackage{lstautogobble}
\usepackage{listings}
\lstdefinestyle{CBaselineStyle}
{
	commentstyle=\color{Blue},
	keywordstyle=\color{Green},
	numberstyle=\tiny\color{gray},
	stringstyle=\color{Fuchsia},
	basicstyle=\ttfamily,
	columns=flexible,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b, % sets the caption position 
	keepspaces=true, % keeps spaces in text, keeping indentation of code
	keywordstyle=\color{blue},
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2,
	% might be adding: stepnummer=2, to have only have every other line numbered
	xleftmargin=1.5em,
	frame=single,
	numbers=left,
	framexleftmargin=1.5em,
	autogobble=true, 
	language=C
}

\lstset{style=CBaselineStyle}

\setcounter{tocdepth}{3}

\usepackage{titling}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}  
\fancyhead[R]{\textsc{Hacking}}  
\fancyfoot[C]{\thepage} 
\renewcommand{\headrulewidth}{0pt} 
\renewcommand{\footrulewidth}{0pt} 

\setlength{\headheight}{55pt} % For the first warning
\addtolength{\topmargin}{-40pt}

\newcommand{\articletype}[1]{\textit{\small #1}\par\vspace{2mm}}  


\pretitle{\flushleft\Large\bfseries}
\posttitle{\vskip 0.5em}

\preauthor{\flushleft\large\lineskip 0.5em}
\postauthor{}


\fancypagestyle{firstpage}{%
  \fancyhead[L]{ \vspace{0.8cm} \footnotesize Kantonsschule Im Lee Winterthur} 
  \fancyhead[R]{\includegraphics[height=1.7cm]{image/ks_im_lee_logo_blue.png}}  
  \renewcommand{\headrulewidth}{0pt}  
  \setlength{\headheight}{55pt}
  \addtolength{\topmargin}{40pt}
    {\footnotesize \hspace{1pt}  Maturitätsarbeit HS2024/25}
    
}



\renewenvironment{abstract}
  {\begin{mdframed}[
    backgroundcolor=gray!20, 
    innertopmargin=10pt, 
    innerbottommargin=15pt, 
    innerleftmargin=15pt, 
    innerrightmargin=15pt, 
    linewidth=0pt, 
    roundcorner=0pt,
    frametitleaboveskip=5mm, 
    frametitlebelowskip=-1mm, 
    frametitle={\bfseries Abstrakt}, 
    frametitlefont={\bfseries},
    frametitlealignment=\raggedright
    ]
   \vspace{2mm}}
  {\end{mdframed}}



\newcommand{\keywords}[1]{
  \vspace{12pt} 
  \par\noindent\textbf{Stichworte:} #1
}



\title{\articletype{Hacking und Cybersicherheit} Die Schattenseiten der digitalen Welt}
\author{Corsin Streit (4a)\textsuperscript{1} unter Aufsicht von Thomas Graf\textsuperscript{2} \\
{\footnotesize \textsuperscript{1}Student, Kantonsschule Im Lee, Winterthur} \\
{\footnotesize \textsuperscript{2}Fachschaft Informatik, Kantonsschule Im Lee, Winterthur} \\
}
\date{
	\vspace{12pt}
	\begin{flushleft}
		\normalsize Winterthur, 23. Dezember 2024
	\end{flushleft}
}

\hypersetup{
	colorlinks=true,
	linkcolor=black,
	citecolor=black,
	urlcolor=black,
}

\renewcommand*{\glstextformat}[1]{\textcolor{purple}{#1}}
\makeglossaries
\input{glossary}

\begin{document}

\maketitle
\thispagestyle{firstpage}


\begin{abstract}
Das Ziel dieser Arbeit besteht darin, durch Literaturrecherche und selbstständiger Nachforschung einen für die Allgemeinheit verständlichen Überblick über das Thema Hacking und Cybersicherheit zu schaffen. Dazu werden technische Grundlagen und Hacking-Methoden erläutert und anhand von konkreten Beispielen anschaulich dargestellt. Ferner wird auf das Thema Dark Web eingegangen.
\end{abstract}

\keywords{Hacking, Cybersicherheit, Hacking-Methoden, Dark Web}

\newpage
\tableofcontents
\newpage

\section{Einführung}
\subsection{Zielsetzung}
Hacking ist ein riesiges Themenfeld, dessen tiefgründiges Verständnis Kenntnisse in vielen Bereichen der Computerwissenschaften voraussetzt. Jede Person, die ein Smartphone, Laptop, Tablet, etc. benutzt, ist den Gefahren des Hackings täglich ausgesetzt, doch nur ein kleiner Bruchteil der Benutzer weiss, was bei einer Hacking-Attacke eigentlich passiert und wie die Konsequenzen aussehen können. Ziel dieser Arbeit ist es, einen Überblick über das Thema Hacking und Cybersicherheit in einer Form zu schaffen, die für die Allgemeinheit verständlich ist. Dabei wird bewusst vor Allem auf leicht verständliche Themenbereiche oder solche, die uns im Alltag am Meisten betreffen eingegangen und die Detailgenauigkeit je nach Thema reduziert. Analysen von modernen Hacking-Attacken sollen dazu beitragen, ein Verständnis der Implementation der Hacking-Methoden zu erlangen und das mögliche Ausmass der Konsequenzen aufzeigen. Zuletzt wird auf das Thema Dark Web eingegangen, da dies als Plattform zur Anonymisierung bei vielen Hacking-Attacken eine Rolle spielt. 

\subsection{Motivationserklärung}
Ich bin grundsätzlich an Computern und dem Programmieren interessiert. Meistens finde ich in meinem durch Sporttrainings ausgefüllten Alltag aber keine Zeit, mich mit dieser Leidenschaft auseinanderzusetzen. Die Maturitätsarbeit schien mir als passende Gelegenheit, mir Wissen in einem computerbezogenen Themengebiet anzueignen. Das Thema Hacking und Cybersicherheit interessiert mich besonders, da ich gerne die Limiten von in diesem Fall Computersystemen teste und es ein Themengebiet ist, das kreatives Denken und logische Schlussfolgerungen voraussetzt und fördert.

\subsection{Methodik}
Es gibt viele verschiedene Methoden, sich mit dem Thema Hacking auseinanderzusetzen. Einsteigern werden oft Videokurse oder Bücher empfohlen, die Themenbereiche, auf die sie einen Fokus setzten, sind aber oft sehr unterschiedlich. Ich habe mich entschieden, meine Arbeit hauptsächlich auf Literatur zu basieren und das Werk ``Hacking - The Art of Exploitation'' von Jon Erickson als Hauptinformationsquelle zu gebrauchen. Unterstützend arbeite ich mit wissenschaftlichen Arbeiten und weiteren, weniger umfangreichen Büchern. Es fällt mir leichter, Informationen anhand von Geschriebenem zu erarbeiten. Ausserdem ist es bei Büchern tendenziell einfacher einzuschätzen, welcher Inhalt erwartet werden kann. Das Buch ``Hacking - The Art of Exploitation'' ist relativ alt (2008), dies passt aber gut zu meiner Zielsetzung, da die Komplexität des Hackings seither exponentiell zugenommen hat und ich eine tiefgründige, verständliche Analyse einer einfachen Hacking-Attacke gegenüber einer oberflächlichen Analyse einer komplexen Attacke bevorzuge. Die Themen weisen aber dennoch einen Bezug zur aktuellen Zeit auf.

\subsection*{Sprach-und Gender-Disclaimer}
\paragraph{Sprache}
Es finden sich englische Begriffe in dieser Arbeit. Da Computerwissenschaften normalerweise in englischer Sprache praktiziert werden, existieren für einige Begriffe keine passende deutsche Übersetzungen. In diesem Falle wird auf die englische Form zurückgegriffen.
\paragraph{Gender}
Teilweise wird nur die männliche Form verwendet. Dies hat zwei Gründe: Zum einen ist die überwiegende Mehrheit der Personen, die in diesem Themenfeld arbeiten und gearbeitet haben, männlich, zum anderen ist die Einbeziehung beider Geschlechter layouttechnisch schwierig ansprechend umzusetzen. In den meisten Fällen sind jedoch beide Geschlechter gemeint, es sei denn, es wird explizit darauf hingewiesen.

\newpage
\section{Ursprung und Bedeutung}
Der Stereotyp ist schlecht wegzudenken. Schwarzer Kapuzenpulli, abgedunkelter Raum und ein Bildschirm mit kryptografischen Zeichen. Auf dem Computer laufen bösartige Programme, die Schwachstellen von anderen ausnutzen und dabei Unheil anrichten. Die Handlung ist kriminell und bestrafbar. Auch wenn diese stereotypische Beschreibung wohl auf eine sehr kleine Gruppe von Personen zutreffen mag, sieht die Realität bedeutend anders aus. Jon Erickson formulierte folgenden Satz: ``Beim Hacken geht es eher darum, das Gesetz zu befolgen als es zu brechen. Das Wesen des Hackens besteht darin, unbeabsichtigte oder übersehene Anwendungen für die Gesetze und Eigenschaften einer gegebenen Situation zu finden und sie dann auf neue und erfinderische Weise anzuwenden, um ein Problem zu lösen - was auch immer es sein mag.'' \texttt{(Erickson, 2008, S. 1, übersetzt mit DeepL)} \cite{erickson2008hacking}



\subsection{Bedeutung und Urpsrung des Begriffes}
Im Grunde genommen ist ein ``Hack'' nichts mehr als eine ``von Innovation, Stil und technischem Können durchdrungene'' Lösung zu einem Problem, das nicht einmal einen Bezug zu Computern aufweisen muss. Den Ursprung nahm der Begriff im Modelleisenbahnclub des \gls{mit}. Aus geschenkten Elektronikbauteilen bauten die Clubmitglieder die Steuerung ihrer Modellzüge. Durch verschiedene Optimierung, Hacks, versuchten sie, diese so elegant wie möglich zu gestalten. Ihr Ziel war nicht das simple Funktionieren. Es war nicht einmal wichtig, dass die Lösung einen grossen Nutzen zeigte. Was zählte, war die technische Eleganz, die hinter der Lösung steckte. \\Mit dem Erscheinen erster Computer und der Gründung eines Computerclubs im \gls{mit} wurde die Bedeutung auf die technische Welt ausgeweitet. Als Steven Levy 1984 die Leiterprinzipen des Hackings zu einer ``Hackerethik'' zusammenfasste, formulierte er folgenden Satz: ``Du kannst mit Computern Kunst und Schönheit schaffen.'' \cite{bpbKleineGeschichte:online}

Das Negative, das viele Personen heute mit dem Hacking assoziieren, wurde erst nach und nach dem Bedeutungskonzept hinzugefügt. Nach weiteren Grundsätzen der Hackerethik sollten sich Hacker für freie Informationszugänglichkeit, Dezentralisierung und unlimitierten Zugriff auf alles, was einen etwas über die Welt lehren kann, einsetzen. Mit den gesetzlichen Richtlinien nahmen sie es nicht genau. Die Neugier, Wissensbegierde und allgemein das technische Interesse führte zur Entdeckung und Erkundung neuer ``Spielwiesen'', was in den 1960er-Jahre zum ersten ``modernen'' Hack führten. Findige Hacker fanden heraus, dass sich durch das Abspielen einer ganz bestimmten Frequenz das Telefonnetz so manipulieren liess, dass Anrufe nicht verrechnet wurden. Sogar Tech-Legenden wie die späteren Apple-Gründer Steve Jobs und Steve Wozniak beteiligten sich an dem sogenannten Blue-Boxing und verdienten Geld durch das Verkaufen von Frequenzgeneratoren, den Blue-Boxes. \\Zeitungsartikel und Filme, insbesondere der 1983 veröffentlichte Titel War Games, trugen in grossem Masse zur heutigen Auffassung des Hackers bei.  Ein Hacker ist ``jemand, der ohne Erlaubnis in die Computersysteme anderer Leute eindringt, um Informationen herauszufinden oder etwas Illegales zu tun.'' \texttt{(Cambridge University Press, Oktober 2024, übersetzt mit DeepL)} \cite{bpbKleineGeschichte:online, CambridgeHacker:online}

\subsection{Motivation, Ethik und Begriffserklärung}
Die Motivationen und Ethiken, die Hacker verfolgen, fallen sehr unterschiedlich aus. Grob kann man sie in zwei Kategorien einteilen: die ``Black Hats'' (auch ``Cracker'' genannt) und die ``White Hats'' (auch ``Penetration Tester'' genannt). \\Black Hat Hacker verfolgen kriminelle Ziele, die (umwelt-)politisch, monetär oder egoistisch motiviert sein können. Oftmals verbreiten sie Malware (Schadsoftware). Dabei ignorieren sie legale und ethische Grundsätze. \\Ihre Gegenspieler sind die White Hat Hacker. Diese benutzen dieselben Methoden, arbeiten aber im Rahmen der Gesetze und halten sich an ethische Grundsätze. Ihre Aufgabe ist es, Privatpersonen, Firmen oder ganz allgemein gefährdete Computer vor den Black Hats zu schützen. Um dies zu bewerkstelligen, hacken sie sich nach vorheriger Absprache mit den Besitzer in Computersysteme ein, um mögliche Sicherheitslücken zu finden und zu beheben. \\ Das Resultat dieses Wettkampfes ist  gewinnbringend. ``Das Endergebnis dieser Interaktion ist positiv, denn es führt zu intelligenteren Menschen, verbesserter Sicherheit, stabilerer Software, erfinderischen Problemlösungstechniken und sogar zu einer neuen Wirtschaft.'' \texttt{(Erickson, 2008, S. 4, übersetzt mit DeepL)} \cite{erickson2008hacking}\\Zwischen den beiden Extremen liegen die Grey Hat Hacker, die zwar oftmals illegal vorgehen, dabei aber keine negativen Absichten verfolgen. Beispielsweise hacken sie sich unberechtigt in ein Firmensystem ein, kommunizieren aber danach die gefunden Schwachstellen. \cite{WhiteHatBlackHat:paper, BlackHat34:online}

Ein weiterer oft verwendeter Begriff ist ``Script Kiddies''. Dies sind ungeschulte (meist junge) Person ohne tiefgründige Hacking-Kenntnisse, die ``von anderen entwickelten Skripts oder Programme für hauptsächlich böswillige Zwecke verwenden'' \texttt{(Wikipedia, Oktober 2024, übersetzt mit DeepL)}. Nichtsdestotrotz können sie grosse Schäden anrichten. \cite{ScriptkiWikipedia:online}

\newpage
\section{Grundlagen der Informatik}
Zum Verständnis des Kapitel \nameref{sec:methoden-und-techniken} sind Grundkenntnisse der Informatik nötig. Diese werden in diesem Kapitel erarbeitet. 
\subsection{Hardwaretechnische Grundlagen}
Ein Computer besteht aus verschiedenen Bestandteilen, die im Zusammenspiel Verarbeitung von Informationen ermöglichen. Folgende Komponenten sind zur Ausführung eines Programms wichtig.
\subsubsection{CPU}\label{subsubsec:cpu}
Die \gls{cpu} beschreibt den wichtigsten Prozessor eines Computers. Mithilfe einer komplexen Platinenstruktur führt er, den Anweisungen eines Programms folgend, Berechnungen durch. 
\paragraph{Register}
Wichtig für die Ausführung eines Programms sind Register. Register sind ``Speicherbereiche für Daten, auf die der Prozessor besonders schnell zugreifen kann''. \cite{RegisterWikipedia:online} Sie speichern zum Beispiel den Fortschritt der Ausführung eines Programms. Einige der wichtigsten Register sind folgende:
\begin{itemize}
	\item \textbf{\gls{eip}}: Befehlszeiger für die jetzige Instruktions-Adresse \cite{UsefulRe7:online}
	\item \textbf{\gls{esp}}: Stapelzeiger für die vorherige Adresse \cite{UsefulRe7:online}
	\item \textbf{\gls{ebp}}: Basiszeiger bei Funktionsaufruf, dient zur Referenzierung lokaler Variablen im Stack \cite{UsefulRe7:online}
	\item \textbf{\gls{sfp}}: Gesicherter Basiszeiger für das vorherige Stack Frame, dient zur Wiederherstellung des ursprünglichen Stack-Zustands \cite{UsefulRe7:online}
\end{itemize}

Die Bedeutung dieser Funktionen wird im Kapitel \nameref{subsec:funktionsweise-eines-programmes} genauer erklärt.
\subsubsection{RAM (Arbeitsspeicher)}
Das \gls{ram} ist ein elektronischer Computerspeicher, dessen Daten sehr schnell und in beliebiger Reihenfolge gelesen und geändert werden können. Er wird deshalb für Daten aktuell laufender Programme verwendet. Oft wird ein Vergleich zum menschlichen Kurzzeitgedächtnis hergestellt. 
\paragraph{Bit und Binärzahlen}
Computer sind nur imstande, Nullen (0) und Einsen (1) zu speichern, sie arbeiten also nur mit zwei Zuständen. Ein \gls{bit} beschreibt einen einzelnen solchen Zustand. Werden mehrere \glspl{bit} zur Datenspeicherung verwendet, steigt die Anzahl möglicher Kombinationen exponentiell auf \( 2^n \) (bei \(n = Anzahl~\glspl{bit}\)) \glspl{bit}. Zahlen werden folgendermassen gespeichert: Die Stelle in der Binärzahl von hinten (also rechts) beginnend dient als Exponent (startend bei null ) zur Basis 2. Bei einer 1 wird die Zahl zur Gesamtzahl addiert, bei 0 nicht. Die (dezimale) Zahl 21 zum Beispiel entspricht der Binärzahl 10101, da sie sich durch (von rechts nach links) \(1 \times 2^0 + 0 \times 2^1 + 1 \times 2^2 + 0 \times 2^3 + 1 \times 2^4 = 21\) zusammensetzt. Zur Konversion können Online-Rechner wie zum Beispiel \url{https://www.rapidtables.com/convert/number/} verwendet werden.

\paragraph{Big and Little Endian Byte Order}
Ein Byte umfasst vier Bits. Zur Ordnung von Bytes existieren zwei Strukturen: Big und Little Endian. Big Endian speichert das wichtigste, also signifikanteste Byte zuerst, während Little Endian dieses zuletzt speichert. Das signifikanteste Byte ist dasjenige, das den grössten Einfluss auf die Gesamtzahl hat, daher normalerweise das am weitesten links stehende.

\paragraph{Speicheradressen}
Jedes \gls{bit} im \gls{ram} ist einzeln adressierbar. Heutzutage arbeiten die meisten Computer mit 32bit oder 64bit Systemen. Dies entspricht der Adresslänge der Speicheradressen und limitiert somit die Anzahl adressierbarer \glspl{bit}. Bei 32bit ist die Ansteuerung von \(2^{32} = 4 294 967 296\) \glspl{bit} möglich, bei 64bit \(2^{64} = 18 446 744 073 709 551 616\). In der Praxis wird dies nur selten ausgereizt. Einfachheitshalber erfolgt die Angabe der Speicheradresse normalerweise im hexadezimalen Format (Basis 16). Dazu werden die Zeichen 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E und F verwendet. Ein Hexadezimalzeichen entspricht vier \glspl{bit} (da \(2^4 = 16\)), eine 32bit Adresse setzt sich also aus acht Hexadezimalstellen zusammen. Hexadezimalzahlen werden üblicherweise mit dem Präfix ``0x'' angekündet. Eine 32bit Speicheradresse könnte folgendermassen aussehen: 0xb7ec819b. \cite{BitWiki31:online}

\subsubsection{HDD/SSD}
Speichermedien, wie hauptsächlich \gls{hdd} und \gls{ssd}, dienen der permanenten Speicherung von Daten, also auch über den Neustart eines Systems hinaus. Ihr Lese- und Schreibzugriff ist langsamer als bei \gls{ram}, die Speicherkapazität dafür meist höher. Oft wird ein Vergleich zum menschlichen Langzeitgedächtnis hergestellt. 

\subsection{Funktionsweise eines Programms}\label{subsec:funktionsweise-eines-programmes}
Hacker schreiben Code, nutzen ihn aber auch aus. Ein Verständnis grundlegender Programmierkonzepte ist deshalb notwendig.
\subsubsection{Einführung}
``Ein Programm ist nichts anderes als eine Reihe von Anweisungen, die in einer bestimmten Sprache geschrieben sind.'' \texttt{(Erickson, 2008, S. 20, übersetzt mit DeepL)} \cite{erickson2008hacking} Es ist vergleichbar mit einem Küchenrezept. Genauso wie das Küchenrezept Menschen sagt, was sie tun sollen, sagt ein Programm dem Computer, was er zu tun hat. Im Gegensatz zu Menschen hat ein Computer aber keinen eigenen Willen und muss sich an die gegebenen Instruktionen halten. In dieser Arbeit liegt der Fokus exemplarisch auf der Programmiersprache C, da damit verbundene Hacking-Methoden beschrieben werden, die grundlegenden Konzepte können aber auf viele Programmiersprachen übertragen werden.
\subsubsection{Grundlagen}
Ein Programm besteht aus verschiedenen Elementen. Die wichtigsten Elemente werden im Folgenden beschrieben.

\paragraph{Kontrollstrukturen}
Kontrollstrukturen steuern den Ablauf eines Programms.
\subparagraph{If-then-else}
If-then-else-Strukturen erlauben die Ausführung eines Programmteiles nur unter bestimmten Bedingungen. Falls die Bedingung nicht erfüllt ist, wird der Programmteil übersprungen oder, wenn angegeben, ein alternativer Programmteil ausegführt.
\subparagraph{While-Schleifen}
While-Schleifen wiederholen einen bestimmten Programmteil solange, bis eine Bedingung erfüllt ist. 
\subparagraph{For-Schleifen}
For-Schleifen werden normalerweise gebraucht, um einen bestimmten Programmteil eine definierte Anzahl mal zu durchlaufen.

\paragraph{Variablen und Konstanen}
Variablen und Konstanten speichern Daten. Variablen sind veränderbar, während Konstanten über die Laufzeit eines Programmes unverändert bleiben. Im Folgenden wird einfachheitshalber von Variablen gesprochen, die beschriebenen Eigenschaften sind aber auch auf Konstanten übertragbar.
\subparagraph{Datentypen}
Bei Variablen wird zwischen verschiedenen Datentypen unterschieden. Einige Programmiersprachen sind bei der Handhabung flexibel und erlauben Veränderungen des Datentyps einer Variable, während andere Variablen bestimmte Datentypen zuordnen. Die Liste bietet eine Auflistung der wichtigsten Datentypen:
\begin{itemize}
	\item \textbf{String}: Text (``Hello'', ``World'')
	\item \textbf{Int}: Ganzzahl (2, 37)
	\item \textbf{Float}: Gleitkommazahl (3.1415, 2.7182)
	\item \textbf{Boolean}: Wahrheitswert (True, False)
	\item \textbf{Array}: Geordnete Liste mit festem Datentyp ([1, 3, 2, 8])
	\item \textbf{List}: Geordnete Liste mit gemischten Datentypen ([2, ``Hello'', True])
	\item \textbf{Dict}: Liste mit Schlüssel-Wert-Paaren ([``Mehl'': 500, ``Zucker'': 200, ``Zitrone'': False])
\end{itemize}
\subparagraph{Gültigkeitsbereich und Lebensdauer}
Variablen sind je nach Initialisierung (Erstellung) nur für bestimmte Teile eines Programms zugänglich. Wird eine Variable beispielsweise in einer Funktion initialisiert, existiert sie nur während der Funktionsausführung. Variablen besitzen folgende Gültigkeitsbereiche:
\begin{itemize}
	\item \textbf{Globale Variablen}: Zugänglich vom gesamten Programm
	\item \textbf{Lokale Variablen}: Zugänglichkeit auf Funktion oder Programmteil limitiert
	\item \textbf{Statische Variablen}: Zugänglichkeit auf Funktion limitiert, behalten jedoch Wert bei erneutem Funktionsaufruf
\end{itemize}
Die verschiedenen Gültigkeitsbereiche führen dazu, dass gleichnamige Variablen mehrere Speicheradressen haben können. In einigen Programmiersprachen müssen Variablen vor der ersten Verwendung initialisiert, also angekündigt, werden.

\paragraph{Arithmetische Operatoren}
Arithmetische Operatoren werden verwendet, um mathematische Operationen durchzuführen. In C stehen die unten aufgelisteten Operatoren zur Verfügung:
\begin{itemize}
	\item \textbf{Addition (+)}: 2 + 3 = 5
	\item \textbf{Subtraktion (-)}: 5 - 3 = 2
	\item \textbf{Multiplikation (*)}: 5 * 3 = 15
	\item \textbf{Division (/)}: 15 / 3 = 5
	\item \textbf{Modulus (\%)}: 15 \% 4 = 3 ((positiver) Rest der Division)
	\item \textbf{Inkrement (++)}: a++ = a + 1
	\item \textbf{Dekrement (--)}: a-- = a - 1
	\item \textbf{Exponentiation (pow())}: pow(a, 3) = $a^3$
\end{itemize}
Für einige Operatoren können Gleichungen, deren Resultat-Variable auch in der Berechnung vorkommt, abgekürzt werden. Statt \(a = a + 5\) lässt sich beispielsweise \(a \text{ += } 5\) schreiben.

\paragraph{Vergleichsoperatoren}
Vergleichsoperatoren dienen dem Vergleich von Variablen oder Werten. Sie geben jeweils True oder False aus. Folgende Operatoren können verwendet werden:
\begin{itemize}
	\item \textbf{Gleichheit (==)}: 5 == 5 $\rightarrow$ True
	\item \textbf{Ungleichheit (!=)}: 5 != 3 $\rightarrow$ True
	\item \textbf{Größer als (>) }: 5 > 3 $\rightarrow$ True
	\item \textbf{Kleiner als (<)}: 5 < 3 $\rightarrow$ False
	\item \textbf{Größer oder gleich (>=)}: 5 >= 5 $\rightarrow$ True
	\item \textbf{Kleiner oder gleich (<=)}: 3 <= 5 $\rightarrow$ True
\end{itemize}

\paragraph{Funktionen}
Funktionen dienen zur Wiederholung bestimmter Programmteile. Sie erlauben einen In- und Output. Der arithmetische Operator pow() ist beispielsweise eine Funktion. Sie erlaubt den Input von \texttt{base} und \texttt{exponent} und gibt die Potenz der beiden Zahlen zurück. Eine Potenz-Funktion für Ganzzahlen könnte so aussehen:
\begin{lstlisting}
	int pow(int base, int exponent) {
		int result = 1; // Startwert für die Multiplikation
		for (int i = 0; i < exponent; i++) {
			result *= base; // Multiplikation
		}
		return result;
	}
\end{lstlisting}

\paragraph{Dateizugriff}
Dateien, die permanent auf einem Speichermedium gespeichert sind, können gelesen, bearbeitet und ausgeführt werden. Ein Benutzer kann dabei aber nur diejenigen Operationen verwenden, deren Rechte er besitzt. Die Identifikation des Benutzers erfolgt über eine ID (beispielsweise 999).

\paragraph{Pseudo-Zufallszahlen}
Bei bestimmten Anwendungen, wie zum Beispiel der Simulation eines Wettermodells oder einem Computerspiel, werden Zufallszahlen benötigt. Computer sind nicht in der Lage, zufällige Zahlen zu generieren. Hauptsächlich wird deshalb auf zwei Alternativen zurückgegriffen: Bei der ersten Möglichkeit werden mathematische Operationen verwendet, die zufällig aussehen. Eine bekannte Methode ist beispielsweise das Quadrieren zehnstelliger Dezimalzahlen. Vom Resultat werden die mittleren zehn Ziffern als neue Zufallszahl angesehen. Eine zweite Möglichkeit ist die Verwendung unvorhersehbarer Prozesse. Dabei wird aus unvorhersehbaren Prozessen wie dem atmosphärischen Rauschen Zahlen generiert.~\cite{Mathemat11:online}

\subsubsection{Abstraktions-Ebenen}
Computer können nur mit aus Einsen und Nullen bestehender Maschinensprache umgehen. Da die Programmierung in Maschinensprache sehr aufwendig und unintuitiv ist, wurden verschiedene Abstraktions-Ebenen eingeführt.

\paragraph{Höhere Programmiersprache (High Level Language)}
Höhere Programmiersprache liegt nahe bei der englischen Sprache und ist (zumindest in Grundzügen) für die meisten Leute intuitiv verständlich. Normalerweise wird in höherer Programmiersprache programmiert. Das Beispiel der Potenz-Funktion oben ist in höherer Programmiersprache angegeben.
\paragraph{Maschinensprache (Machine Language)}
Maschinensprache besteht nur aus Einsen und Nullen und ist auch für die meisten professionellen Programmierer unverständlich. Der Code \(x = 3 + 5\) könnte so aussehen: 
b8 05 00 00 00
83 c0 03 
. (Angabe im hexadezimalen Format)
\paragraph{Assemblersprache (Assembly Language)}
Assemblersprache kann als die Verbalisierung der Maschinensprache angesehen werden und wird teilweise zur Programmierung verwendet. Dies aber nur bei sehr systemnahen Anwendungen. Derselbe Code \(x = 3 + 5\) könnte in Assemblersprache so aussehen: 
mov eax, 5
add eax, 3
. Hier werden auch die in Kapitel~\ref{subsubsec:cpu} erwähnten Register ersichtlich.

Zur Übersetzung zwischen den Abstraktionsebenen dienen der Compiler und Assembler. Der Compiler transformiert höhere Programmiersprache in Maschinensprache, der Assembler Assemblersprache in Maschinensprache.

\subsubsection{Ablauf zur Ausführung}
Die Ausführung eines Programms folgt folgendem Grundprinzip:
\begin{enumerate}
	\item Der Code wird kompiliert (oder assembliert) und als Maschinencode im RAM gespeichert.
	\item Die Instruktion, zu der das \gls{eip}-Register zeigt, wird gelesen.
	\item Die Bitlänge der Instruktion wird zum \gls{eip} addiert, der \gls{eip} zeigt jetzt also zur nächsten Instruktion.
	\item Die Instruktion wird ausgeführt.
	\item Neustart bei Schritt 2.
\end{enumerate}

\subsubsection{Speichersegmentierung in C}
Die Datenanordnung im RAM folgt einer bestimmten Struktur. Bei C wird sie in fünf Segmente aufgeteilt.
\begin{itemize}
	\item \textbf{Text Segment}: Speichert Code (in Maschinensprache), ist unveränderlich
	\item \textbf{Initialized Data}: Speichert initialisierte globale und statische Variablen
	\item \textbf{Uninitialized Data}: Speichert uninitialisierte Variablen
	\item \textbf{Heap Segment}: Ist kontrollierbar durch den Programmierer, wächst von niedrigen zu hohen Adressen~\cite{StackHeapYoutube:online}
	\item \textbf{Stack Segment}: Speichert den Kontext und lokale Variablen bei Funktionsaufrufen, funktioniert nach LIFO-Prinzip (last-in-first-out): wächst von hohen zu niedrigen Adressen und wird umgekehrt abgearbeitet~\cite{StackHeapYoutube:online}
\end{itemize}
Unter dem Stack werden Umgebungsvariablen und Befehlszeilenargumente gespeichert. Umgebungsvariablen enthalten Information zur Umgebung des Systemes~\cite{UmgebungsMicrosoft:online} und Befehlszeilenargumente sind vom Benutzer beim Programmstart eingegebene Daten.

\paragraph{Stack Frame}
Ein Stack Frame ist ``ein Abschnitt des Stacks, der einem bestimmten Funktionsaufruf gewidmet ist.''~\texttt{(NordVPN, Dezember 2024, übersetzt mit DeepL)}\cite{StackFrameNordVPN:online} Das Stack Frame der aufgerufenen Funktion wird oberhalb des Stack Frame der aktuellen Funktion erstellt und enthält alle wichtigen Informationen. Dazu gehören unter anderem Variablen, der \gls{ebp} und die Rückkehradresse. Die Rückkehradresse wird benötigt, um an der richtigen Stelle zur ursprünglichen Funktion zurückzukehren.

\subsection{Funktionsweise eines Netzwerks}
Viele Hacking-Attacken nutzen Schwachstellen in Netzwerken aus. Für Hacker sind Netzwerk-Attacken sehr attraktiv, da sie keinen physischen Zugriff auf Infrastruktur erfordern.
\subsubsection{Einführung}
Ein Netzwerk ist ein ``großes System, das aus vielen ähnlichen Teilen besteht, die miteinander verbunden sind, um eine Bewegung oder Kommunikation zwischen den Teilen oder zwischen den Teilen und einem Kontrollzentrum zu ermöglichen.''~\texttt{(Cambridge University Press, Dezember 2024, übersetzt mit DeepL)} Anwendungen wie das \gls{www} oder WhatsApp-Nachrichten basieren auf einer Netzwerkstruktur. Ein Netzwerk ist aber nicht dem Internet gleichzusetzen und kann auch lokal existieren. naja

\subsubsection{OSI-Modell}
Das \gls{osi}-Modell standardisiert den Netzwerkverkehr und bietet damit die Grundlage der Datenübertragung. Das Modell wurde in in den 1980er-Jahren von der \gls{iso} entwickelt und ist heute mehrheitlich von dem \gls{tcp}/\gls{ip}-Modell abgelöst, wird wegen besserer Übersichtlichkeit aber oft zu Unterrichtszwecken verwendet.~\cite{OSImodelWikipedia:online}
\paragraph{Einführung}
Das \gls{osi}-Modell ist in sieben Ebenen mit jeweils spezifischen Funktionen zum Datentransport organisiert. Ebene sieben ist dabei am nächsten bei der Anwendung, während Ebene eins am nächsten bei der physischen Hardware liegt. Bevor Daten transportiert werden, werden sie bei Ebene sieben beginnend in alle Ebenen verpackt. Beim Erhalt werden sie wieder entpackt. Zwischengeräte wie Router, die für die Weiterleitung der Datenpakete verantwortlich sind, packen die Daten nur soweit, wie für die Weiterleitung nötig, aus. Meist entspricht dies Ebene drei. Datenpakete bestehen aus einem Header und Daten. Der Header enthält wichtige Informationen zum Datentransport, so zum Beispiel die Datenlänge oder die Senderadresse. 
\paragraph{Netzwerkprotokolle}
Netzwerkprotokolle standardisieren die Struktur eines Datenpaketes. Sie sind für die korrekte Formatierung der Daten verantwortlich und bestimmen den Inhalt des Headers. Damit ermöglichen sie verschiedenen Geräten eine einheitliche Kommunikationsbasis. Die Auflistung der sieben Ebenen weiter unten bietet einige Beispiele.
\paragraph{Die sieben Ebenen}
Im Anschluss findet sich eine Auflistung der sieben Ebenen. Wichtige Eigenschaften oder Protokolle einer Ebene werden untergeordnet angegeben.
\begin{itemize}
	\item \textbf{1. Bitübertragung}: Verantwortlich für die physische Verbindung zwischen zwei Punkten, überträgt einzelne \glspl{bit} (zum Beispiel Ethernet-Kabel, Bluetooth)
	\item \textbf{2. Sicherung}: Zuständig für zuverlässige Übertragung der Daten inklusive Fehlerkorrektur und Flusskontrolle.
	\begin{itemize}
		\item \gls{mac}-Adressen: Hardware-Adressen, werden zur Kommunikation auf Level 2 benötigt. Normalerweise (im Gegensatz zur \gls{ip}-Adresse) gerätespezifisch.
		\item \gls{arp}: Wandelt \gls{ip}-Adressen (Level 3) in \gls{mac}-Adressen (Level 2) um. Dazu sendet es Anfrage mit einer \gls{ip}-Adresse an die Broadcasting-Adresse eines Netzwerkes (Adresse, die alle Geräte in einem Netzwerk umfasst). Das Gerät mit entsprechender \gls{ip}-Adresse antwortet mit seiner \gls{mac}-Adresse.
	\end{itemize}
	\item \textbf{3. Vermittlung}: Entscheidet über den Pfad der Daten, kümmert sich um die Fragmentierung (Aufteilung von Datenpaketen bei Überschreitung der maximalen Datenmenge).
	\begin{itemize}
		\item \gls{ip}-Adresse: Wird jedem internetfähigen Gerät zugewiesen wird und zur Kommunikation auf Level 3 benötigt.
		\item \gls{icmp}: Meldet Fehler und führt Netzdiagnosen durch. Das \texttt{ping}-Kommando testet beispielsweise die Verbindung zwischen zwei Geräten.~\cite{ICMPFortinet:online}
	\end{itemize}
	\item \textbf{4. Transport}: Sorgt für Ende-zu-Ende-Kommunikation zwischen Anwendungen. Hauptsächlich werden zwei Protokolle verwendet.
	\begin{itemize}
		\item \gls{udp}: Einseitiges, verbindungsloses, unzuverlässiges, aber ressourcenschonendes Protokoll, dass für zeitkritische Datenübertragung geeignet wie Videostreaming oder Online-Gaming geeignet ist.
		\item \gls{tcp}: Zweiseitiges, verbindungsbasiertes, zuverlässiges, dafür ressourcenintensives Protokoll, dass für Anwendungen mit hoher Datenintegrität wie Dateiübertragungen, E-Mails oder Webinhalte geeignet ist.
	\end{itemize}
	\item \textbf{5. Kommunikation}: Verwaltet Verbindungen durch Erstellung, Aufrechterhaltung und Auflösung.
	\item \textbf{6. Darstellung}: Formatiert und ver- oder entschlüsselt Daten für die Endanwendung.
	\item \textbf{7. Anwendung}: Schnittstelle einer Anwendungen zum Netzwerk.
	\begin{itemize}
		\item \gls{http} und \gls{https}: Kommunikationsprotokolle für das \gls{www}. \gls{https} ist im Gegensatz zu \gls{http} verschlüsselt.~\cite{HTTPWiki6:online, HTTPvers49:online} Die wichtigsten Anfrage-Methoden sind folgende:
		\begin{itemize}
			\item GET: Fordert spezifische Ressource an.
			\item HEAD: Fordert nur Header ohne Kontext an.
			\item POST: Sendet Daten an Server.
		\end{itemize}
		\item \gls{dns}: Protokoll zur Umwandlung von Hostnamen wie \url{www.google.com} in \gls{ip}-Adressen.
		\item \gls{pop3}: Veraltetes Protokoll zum Senden und Empfangen von E-Mails.~\cite{Pop3microsoft:online}
	\end{itemize}
\end{itemize}

\subsubsection{Sockets}
Sockets dienen als Endpunkte einer Verbindung und werden vom Betriebssystem bereitgestellt.~\cite{SocketW33:online} Sie operieren hauptsächlich auf Level 4. Sockets werden anhand von drei Eigenschaften unterschieden
\paragraph{Domain}
Die Domain legt fest, wie Adressen angegeben werden. Mögliche Optionen sind sind zum Beispiel \gls{ip} (Version 4) (\texttt{AF\_INET}) oder Bluetooth (\texttt{AF\_BLUETOOTH}).
\paragraph{Typ}
Drei Typen von Sockets existieren: Stream Sockets, Datagram Sockets und raw sockets. Normalerweise werden Stream Sockets mit dem \gls{tcp} benutzt, währenddessen Datagram Sockets das \gls{udp} verwenden. Dies führt auch zu den jeweiligen Eigenschaften: Stream Sockets sind zuverlässig aber langsam, Datagram Sockets schnell aber unzuverlässig. Raw Sockets erlauben die Miteinbeziehung und Analyse von tiefer liegenden Netzwerkebenen. 
\paragraph{Protokoll}
Das Protokoll spezifiziert, welches Protokoll auf Ebene vier verwendet werden sollte. Im Normalfall muss dies nicht explizit angegeben werden, da das System standardmässig das zum Typ des Sockets passende Protokoll auswählt.


\newpage
\section{Methoden und Techniken}\label{sec:methoden-und-techniken}
Hacking-Attacken sind sehr unterschiedlich und fokussieren sich auf verschiedene Bereiche eines Computersystems. Einige erfordern physischen Zugriff auf ein System während andere über ein Netzwerk erfolgen. Dieses Kapitel zeigt exemplarisch einige gut verständliche Hacking-Methoden und Techniken auf. Die Kapitel folgen derselben Struktur: Zuerst wird die allgemeine Funktionsweise einer Attacke beschrieben und danach auf die Abwehrmechanismen eingegangen. In einigen Kapiteln findet sich auch ein konkretes Beispiel mit Code. Zuletzt folgt ein Kapitel mit Erklärungen zu bekannten Begriffen, die bis dahin noch nicht vorgekommen sind.

\subsection{Buffer-overflow}
Ein Buffer beschreibt einen reservierten Speicherbereich, um Daten temporär zu speichern. Ein Buffer-overflow tritt auf, wenn mehr Daten in diesen Bereich geschrieben werden, als die Kapazität erlaubt. Dies kann dazu führen, dass zur Ausführung des Programms wichtige Daten überschrieben werden und das Programm anders abläuft, als vom Programmierer ursprünglich geplant. Programmiersprachen wie C, bei denen sich \gls{ram} sehr direkt kontrollieren lässt, sind besonders anfällig für Attacken dieser Art. Moderne Programmiersprachen besitzen oft eine automatische Speicherverwaltung, die die direkte Kontrolle des \gls{ram} erschweren oder sogar verunmöglichen.

\subsubsection{Allgemeine Funktionsweise}
Voraussetzung dieser Attacke ist ein Programm, das Daten (zum Beispiel Text) als Input annimmt und diese in das \gls{ram} kopiert, ohne vorher zu überprüfen, ob ausreichend Platz reserviert wurde. Der Angreifer kann den Input nun bewusst zu lange und mit ganz bestimmten Zeichenfolgen wählen. Ziel ist oft die Überschreibung der Rückkehradresse einer Funktion, so dass das Programm dann auf eigens im \gls{ram} platzierten Code (Shellcode) umgelenkt wird. Dies ist besonders kritisch, wenn das Programm mit Root-, also Administrationsrechten ausgeführt wird, da der Angreifer dann die Kontrolle über das gesamte System erlangen kann. \\Zur Ausführung der Attacke muss also ein Input gewählt werden, der eine neue Rückkehradresse und den Shellcode enthält. Die neue Rückkehradresse zeigt auf den Shellcode und lässt diesen bei Funktionsende ausführen. Dabei stösst man jedoch auf zwei Probleme:
\begin{enumerate}
	\item Meist ist es schwer abzuschätzen, wo genau die neue Rückkehradresse im Input platziert werden muss, damit sie genau die originale Rückkehradresse trifft. Die Speichersegmentierung kann zwischen Programmausführungen variieren und lässt nur schwer eine exakte Vorhersage zu. Dieses Problem lässt sich jedoch einfach durch das wiederholte speichern der Rückkehradresse lösen. Wenn man statt nur eine einen ganzen Bereich mit Rückkehradressen füllt, erhöht sich die Wahrscheinlichkeit, die Rückkehradresse zu treffen, massiv.
	\item Das zweite Problem bezieht sich auf die Vorhersage der Speicheradresse des Shellcodes. Da eine exakte Rückkehradresse angegeben werden muss, die genau auf den Start des Shellcodes zeigen muss, lässt sich das Problem nicht durch Wiederholung lösen. Stattdessen greift man auf einen \gls{nop} sled zurück.
	\paragraph{NOP sled}
	Ein \gls{nop} sled beschreibt eine Reihe von \gls{nop}-Instruktionen. Diese Instruktionen tun nichts, ausser zur nächsten Instruktion zu springen, bis schliesslich der finale Code (in diesem Fall Shellcode) erreicht wird.
	
	Die Platzierung eines langen \gls{nop} sled vor dem Shellcode macht eine genaue Vorhersage der Speicheradresse des Shellcodes überflüssig. Es reicht, wenn die Rückkehradresse den \gls{nop} sled trifft.
\end{enumerate}

Der finale Input hat dementsprechend folgendes Format:
\newline
\begin{center}
	\centerline{| NOP | NOP | NOP | SHELLCODE | RET | RET | RET |}
\end{center}

\subsubsection{Abwehrmechanismen}

\subsubsection{Konkretes Beispiel}


\subsection{Format String exploitation}

\subsubsection{Allgemeine Funktionsweise}

\subsubsection{Abwehrmechanismen}

\subsubsection{Konkretes Beispiel}


\subsection{Network Sniffing}

\subsubsection{Allgemeine Funktionsweise}

\subsubsection{Abwehrmechanismen}

\subsubsection{Konkretes Beispiel}


\subsection{Man-in-the-Middle}

\subsubsection{Allgemeine Funktionsweise}

\subsubsection{Abwehrmechanismen}

\subsubsection{evtl. Konkretes Beispiel}


\subsection{Denial of Service}

\subsubsection{Allgemeine Funktionsweise}

\subsubsection{Abwehrmechanismen}

\subsubsection{evtl. Konkretes Beispiel}


\subsection{Erklärung weiterer Begriffe}
\begin{itemize}
	\item Phishing
	\item Passwort-Attacken
	\item Ransomware
	\item Viren
	\item Würmer
	\item Trojaner
	\item Malware
\end{itemize}


\section{Analyse bekannter Hackerangriffen}

\subsection{Russische Einflussnahme auf die Präsidentschaftswahlen (2016)}

\subsection{Angriff auf das ukrainische Stromnetz (2015)}

\subsection{WannaCry Ransomware (2017)}


\section{Das Dark Web}

\subsection{Grundlagen}

\subsection{Zugangsmechanismen und Tools}

\subsection{Sicherheitsrisiken}

\section{Diskussion}
was ist rausgekommen?

\section{Ausblick}
was hätte man noch machen können?


\appendix
\newpage
\renewcommand{\thesubsection}{\Alph{subsection}}
\counterwithin{figure}{subsection}
\counterwithin{table}{subsection}
\pagebreak

\section{Appendix}
\subsection{Code}
\subsubsection{exploit\_notesearch.c}
\label{exploit_notesearch.c}
\lstinputlisting{code_files/buffer-overflow/exploit-notesearch.c}



\newpage
\printbibliography
\listoffigures
\listoftables
\printglossaries
\end{document}
