% !TeX spellcheck = de_CH
\documentclass[11pt, a4paper]{article}
\usepackage[margin=2.54cm]{geometry}

% !TeX program = lualatex


% Fonts
\usepackage{fourier-otf}
\usepackage{fontspec}
\setmainfont{Heuristica}  

% Math
\usepackage{amsmath, amsthm, mathrsfs,bm}

\usepackage[ngerman]{babel}
\usepackage{csquotes}

\usepackage{booktabs}
\usepackage{url}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{comment}
\usepackage[dvipsnames, x11names]{xcolor}
\usepackage{lipsum} 
\usepackage{mdframed}  
\usepackage[backend=biber]{biblatex}
\addbibresource{refs.bib}
\graphicspath{{image}}
\usepackage{setspace}
\usepackage{parskip}
\onehalfspacing

\usepackage{nameref}
\usepackage[]{hyperref}
\usepackage[acronym, nomain]{glossaries}
\usepackage{chngcntr}

\usepackage{lstautogobble}
\usepackage{listings}
\lstdefinestyle{CBaselineStyle}
{
	commentstyle=\color{Blue},
	keywordstyle=\color{Green},
	numberstyle=\tiny\color{gray},
	stringstyle=\color{Fuchsia},
	basicstyle=\ttfamily,
	columns=flexible,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b, % sets the caption position 
	keepspaces=true, % keeps spaces in text, keeping indentation of code
	keywordstyle=\color{blue},
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2,
	% might be adding: stepnummer=2, to have only have every other line numbered
	xleftmargin=1.5em,
	frame=single,
	numbers=left,
	framexleftmargin=1.5em,
	autogobble=true, 
	language=C
}

\definecolor{lightgray}{rgb}{0.95, 0.95, 0.95}

\lstdefinestyle{COutputStyle}
{
	language=C,
	backgroundcolor=\color{lightgray},
	frame=single,
	rulecolor=\color{lightgray},
	numbers=none,
	xleftmargin=1.5em,
	xrightmargin=0em,
	belowskip=0pt
}

\lstdefinestyle{LowLevelStyle}
{
	language=[x86masm]Assembler,
	basicstyle=\ttfamily,
	keywordstyle=\color{blue},
	backgroundcolor=\color{lightgray},
	frame=single,
	rulecolor=\color{lightgray},
	xleftmargin=1.5em,
	xrightmargin=0em,
	belowskip=0pt
}


\lstset{
	style=CBaselineStyle, 
	escapeinside={(*@}{@*)}
}

\setcounter{tocdepth}{3}

\usepackage{titling}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}  
\fancyhead[R]{\textsc{Hacking}}  
\fancyfoot[C]{\thepage} 
\renewcommand{\headrulewidth}{0pt} 
\renewcommand{\footrulewidth}{0pt} 

\setlength{\headheight}{55pt} % For the first warning
\addtolength{\topmargin}{-40pt}

\newcommand{\articletype}[1]{\textit{\small #1}\par\vspace{2mm}}  


\pretitle{\flushleft\Large\bfseries}
\posttitle{\vskip 0.5em}

\preauthor{\flushleft\large\lineskip 0.5em}
\postauthor{}


\fancypagestyle{firstpage}{%
  \fancyhead[L]{ \vspace{0.8cm} \footnotesize Kantonsschule Im Lee Winterthur} 
  \fancyhead[R]{\includegraphics[height=1.7cm]{image/ks_im_lee_logo_blue.png}}  
  \renewcommand{\headrulewidth}{0pt}  
  \setlength{\headheight}{55pt}
  \addtolength{\topmargin}{40pt}
    {\footnotesize \hspace{1pt}  Maturitätsarbeit HS2024/25}
    
}



\renewenvironment{abstract}
  {\begin{mdframed}[
    backgroundcolor=gray!20, 
    innertopmargin=10pt, 
    innerbottommargin=15pt, 
    innerleftmargin=15pt, 
    innerrightmargin=15pt, 
    linewidth=0pt, 
    roundcorner=0pt,
    frametitleaboveskip=5mm, 
    frametitlebelowskip=-1mm, 
    frametitle={\bfseries Abstrakt}, 
    frametitlefont={\bfseries},
    frametitlealignment=\raggedright
    ]
   \vspace{2mm}}
  {\end{mdframed}}



\newcommand{\keywords}[1]{
  \vspace{12pt} 
  \par\noindent\textbf{Stichworte:} #1
}



\title{\articletype{Hacking und Cybersicherheit} Die Schattenseiten der digitalen Welt}
\author{Corsin Streit (4a)\textsuperscript{1} unter Aufsicht von Thomas Graf\textsuperscript{2} \\
{\footnotesize \textsuperscript{1}Student, Kantonsschule Im Lee, Winterthur} \\
{\footnotesize \textsuperscript{2}Fachschaft Informatik, Kantonsschule Im Lee, Winterthur} \\
}
\date{
	\vspace{12pt}
	\begin{flushleft}
		\normalsize Winterthur, 23. Dezember 2024
	\end{flushleft}
}

\hypersetup{
	colorlinks=true,
	linkcolor=green,
	citecolor=black,
	urlcolor=black,
}

\renewcommand*{\glstextformat}[1]{\textcolor{purple}{#1}}
\makeglossaries
\input{glossary}

\begin{document}

\maketitle
\thispagestyle{firstpage}


\begin{abstract}
Das Ziel dieser Arbeit besteht darin, durch Literaturrecherche und selbstständiger Nachforschung einen für die Allgemeinheit verständlichen Überblick über das Thema Hacking und Cybersicherheit zu schaffen. Dazu werden technische Grundlagen und Hacking-Methoden erläutert und anhand von konkreten Beispielen anschaulich dargestellt. Ferner wird auf das Thema Dark Web eingegangen.
\end{abstract}

\keywords{Hacking, Cybersicherheit, Programmieren, Netzwerk Hacking-Methoden}

\newpage
\hypersetup{linkcolor=black}
\tableofcontents
\hypersetup{linkcolor=RoyalBlue}
\newpage

\section{Einführung}
\subsection{Zielsetzung}
Hacking ist ein riesiges Themenfeld, dessen tiefgründiges Verständnis Kenntnisse in vielen Bereichen der Computerwissenschaften voraussetzt. Jede Person, die ein Smartphone, Laptop, Tablet, etc. benutzt, ist den Gefahren des Hackings täglich ausgesetzt, doch nur ein kleiner Bruchteil der Benutzer weiss, was bei einer Hacking-Attacke eigentlich passiert und wie die Konsequenzen aussehen können. Ziel dieser Arbeit ist es, einen Überblick über das Thema Hacking und Cybersicherheit in einer Form zu schaffen, die für die Allgemeinheit verständlich ist. Dabei wird bewusst vor Allem auf leicht verständliche Themenbereiche oder solche, die uns im Alltag am Meisten betreffen eingegangen und die Detailgenauigkeit je nach Thema reduziert. Analysen von modernen Hacking-Attacken sollen dazu beitragen, ein Verständnis der Implementation der Hacking-Methoden zu erlangen und das mögliche Ausmass der Konsequenzen aufzeigen. Zuletzt wird auf das Thema Dark Web eingegangen, da dies als Plattform zur Anonymisierung bei vielen Hacking-Attacken eine Rolle spielt. 

\subsection{Motivationserklärung}
Ich bin grundsätzlich an Computern und dem Programmieren interessiert. Meistens finde ich in meinem durch Sporttrainings ausgefüllten Alltag aber keine Zeit, mich mit dieser Leidenschaft auseinanderzusetzen. Die Maturitätsarbeit schien mir als passende Gelegenheit, mir Wissen in einem computerbezogenen Themengebiet anzueignen. Das Thema Hacking und Cybersicherheit interessiert mich besonders, da ich gerne die Limiten von in diesem Fall Computersystemen teste und es ein Themengebiet ist, das kreatives Denken und logische Schlussfolgerungen voraussetzt und fördert.

\subsection{Methodik}
Es gibt viele verschiedene Methoden, sich mit dem Thema Hacking auseinanderzusetzen. Einsteigern werden oft Videokurse oder Bücher empfohlen, die Themenbereiche, auf die sie einen Fokus setzten, sind aber oft sehr unterschiedlich. Ich habe mich entschieden, meine Arbeit hauptsächlich auf Literatur zu basieren und das Werk ``Hacking - The Art of Exploitation''~\cite{erickson2008hacking} von Jon Erickson als Hauptinformationsquelle zu gebrauchen. Unterstützend arbeite ich mit wissenschaftlichen Arbeiten und weiteren, weniger umfangreichen Büchern. Es fällt mir leichter, Informationen anhand von Geschriebenem zu erarbeiten. Ausserdem ist es bei Büchern tendenziell einfacher einzuschätzen, welcher Inhalt erwartet werden kann. Das Buch ``Hacking - The Art of Exploitation''~\cite{erickson2008hacking} ist relativ alt (2008), dies passt aber gut zu meiner Zielsetzung, da die Komplexität des Hackings seither exponentiell zugenommen hat und ich eine tiefgründige, verständliche Analyse einer einfachen Hacking-Attacke gegenüber einer oberflächlichen Analyse einer komplexen Attacke bevorzuge. Die Themen weisen aber dennoch einen Bezug zur aktuellen Zeit auf.

\subsection*{Quellenangabe}
Der Hauptteil des Wissens in den Kapiteln \nameref{sec:grundlagen-der-informatik} (\ref{sec:grundlagen-der-informatik}) und \nameref{sec:methoden-und-techniken} (\ref{sec:methoden-und-techniken}) wurde mit Hilfe des Buches ``Hacking - The Art of Exploitation''~\cite{erickson2008hacking} erarbeitet. Zur besseren Übersichtlichkeit wurden deshalb die Quellenangaben dieses Buches auf eine am Anfang der Kapitel beschränkt. Explizite Zitate werden immer gekennzeichnet.

\subsection*{Disclaimer}
\paragraph{Sprache}
Es finden sich englische Begriffe in dieser Arbeit. Da Computerwissenschaften normalerweise in englischer Sprache praktiziert werden, existieren für einige Begriffe keine passende deutsche Übersetzungen. In diesem Falle wird auf die englische Form zurückgegriffen.
\paragraph{Gender}
Teilweise wird nur die männliche Form verwendet. Dies hat zwei Gründe: Zum einen ist die überwiegende Mehrheit der Personen, die in diesem Themenfeld arbeiten und gearbeitet haben, männlich, zum anderen ist die Einbeziehung beider Geschlechter layouttechnisch schwierig ansprechend umzusetzen. In den meisten Fällen sind jedoch beide Geschlechter gemeint, es sei denn, es wird explizit darauf hingewiesen.

\newpage
\section{Ursprung und Bedeutung}
Der Stereotyp ist schlecht wegzudenken. Schwarzer Kapuzenpulli, abgedunkelter Raum und ein Bildschirm mit kryptografischen Zeichen. Auf dem Computer laufen bösartige Programme, die Schwachstellen von anderen ausnutzen und dabei Unheil anrichten. Die Handlung ist kriminell und bestrafbar. Auch wenn diese stereotypische Beschreibung wohl auf eine sehr kleine Gruppe von Personen zutreffen mag, sieht die Realität bedeutend anders aus. Jon Erickson formulierte folgenden Satz: ``Beim Hacken geht es eher darum, das Gesetz zu befolgen als es zu brechen. Das Wesen des Hackens besteht darin, unbeabsichtigte oder übersehene Anwendungen für die Gesetze und Eigenschaften einer gegebenen Situation zu finden und sie dann auf neue und erfinderische Weise anzuwenden, um ein Problem zu lösen - was auch immer es sein mag.'' \texttt{(Erickson, 2008, S. 1, übersetzt mit DeepL)} \cite{erickson2008hacking}



\subsection{Bedeutung und Urpsrung des Begriffes}
Im Grunde genommen ist ein ``Hack'' nichts mehr als eine ``von Innovation, Stil und technischem Können durchdrungene'' Lösung zu einem Problem, das nicht einmal einen Bezug zu Computern aufweisen muss. Den Ursprung nahm der Begriff im Modelleisenbahnclub des \gls{mit}. Aus geschenkten Elektronikbauteilen bauten die Clubmitglieder die Steuerung ihrer Modellzüge. Durch verschiedene Optimierung, Hacks, versuchten sie, diese so elegant wie möglich zu gestalten. Ihr Ziel war nicht das simple Funktionieren. Es war nicht einmal wichtig, dass die Lösung einen grossen Nutzen zeigte. Was zählte, war die technische Eleganz, die hinter der Lösung steckte. \\Mit dem Erscheinen erster Computer und der Gründung eines Computerclubs im \gls{mit} wurde die Bedeutung auf die technische Welt ausgeweitet. Als Steven Levy 1984 die Leiterprinzipen des Hackings zu einer ``Hackerethik'' zusammenfasste, formulierte er folgenden Satz: ``Du kannst mit Computern Kunst und Schönheit schaffen.'' \cite{bpbKleineGeschichte:online}

Das Negative, das viele Personen heute mit dem Hacking assoziieren, wurde erst nach und nach dem Bedeutungskonzept hinzugefügt. Nach weiteren Grundsätzen der Hackerethik sollten sich Hacker für freie Informationszugänglichkeit, Dezentralisierung und unlimitierten Zugriff auf alles, was einen etwas über die Welt lehren kann, einsetzen. Mit den gesetzlichen Richtlinien nahmen sie es nicht genau. Die Neugier, Wissensbegierde und allgemein das technische Interesse führte zur Entdeckung und Erkundung neuer ``Spielwiesen'', was in den 1960er-Jahre zum ersten ``modernen'' Hack führten. Findige Hacker fanden heraus, dass sich durch das Abspielen einer ganz bestimmten Frequenz das Telefonnetz so manipulieren liess, dass Anrufe nicht verrechnet wurden. Sogar Tech-Legenden wie die späteren Apple-Gründer Steve Jobs und Steve Wozniak beteiligten sich an dem sogenannten Blue-Boxing und verdienten Geld durch das Verkaufen von Frequenzgeneratoren, den Blue-Boxes. \\Zeitungsartikel und Filme, insbesondere der 1983 veröffentlichte Titel War Games, trugen in grossem Masse zur heutigen Auffassung des Hackers bei.  Ein Hacker ist ``jemand, der ohne Erlaubnis in die Computersysteme anderer Leute eindringt, um Informationen herauszufinden oder etwas Illegales zu tun.'' \texttt{(Cambridge University Press, Oktober 2024, übersetzt mit DeepL)} \cite{bpbKleineGeschichte:online, CambridgeHacker:online}

\subsection{Motivation, Ethik und Begriffserklärung}
Die Motivationen und Ethiken, die Hacker verfolgen, fallen sehr unterschiedlich aus. Grob kann man sie in zwei Kategorien einteilen: die ``Black Hats'' (auch ``Cracker'' genannt) und die ``White Hats'' (auch ``Penetration Tester'' genannt). \\Black Hat Hacker verfolgen kriminelle Ziele, die (umwelt-)politisch, monetär oder egoistisch motiviert sein können. Oftmals verbreiten sie Malware (Schadsoftware). Dabei ignorieren sie legale und ethische Grundsätze. \\Ihre Gegenspieler sind die White Hat Hacker. Diese benutzen dieselben Methoden, arbeiten aber im Rahmen der Gesetze und halten sich an ethische Grundsätze. Ihre Aufgabe ist es, Privatpersonen, Firmen oder ganz allgemein gefährdete Computer vor den Black Hats zu schützen. Um dies zu bewerkstelligen, hacken sie sich nach vorheriger Absprache mit den Besitzer in Computersysteme ein, um mögliche Sicherheitslücken zu finden und zu beheben. \\ Das Resultat dieses Wettkampfes ist  gewinnbringend. ``Das Endergebnis dieser Interaktion ist positiv, denn es führt zu intelligenteren Menschen, verbesserter Sicherheit, stabilerer Software, erfinderischen Problemlösungstechniken und sogar zu einer neuen Wirtschaft.'' \texttt{(Erickson, 2008, S. 4, übersetzt mit DeepL)} \cite{erickson2008hacking}\\Zwischen den beiden Extremen liegen die Grey Hat Hacker, die zwar oftmals illegal vorgehen, dabei aber keine negativen Absichten verfolgen. Beispielsweise hacken sie sich unberechtigt in ein Firmensystem ein, kommunizieren aber danach die gefunden Schwachstellen. \cite{WhiteHatBlackHat:paper, BlackHat34:online}

Ein weiterer oft verwendeter Begriff ist ``Script Kiddies''. Dies sind ungeschulte (meist junge) Person ohne tiefgründige Hacking-Kenntnisse, die ``von anderen entwickelten Skripts oder Programme für hauptsächlich böswillige Zwecke verwenden'' \texttt{(Wikipedia, Oktober 2024, übersetzt mit DeepL)}. Nichtsdestotrotz können sie grosse Schäden anrichten. \cite{ScriptkiWikipedia:online}

\newpage
\section{Grundlagen der Informatik}\label{sec:grundlagen-der-informatik}
Zum Verständnis des Kapitel \nameref{sec:methoden-und-techniken} (\ref{sec:methoden-und-techniken}) sind Grundkenntnisse der Informatik nötig. Diese werden in diesem Kapitel erarbeitet. Wie am Anfang bereits erwähnt diente, sofern keine andere Quelle angegeben wurde, das Buch ``Hacking - The Art of Exploitation''~\cite{erickson2008hacking} als Hauptquelle dieses Kapitels.
\subsection{Hardwaretechnische Grundlagen}
Ein Computer besteht aus verschiedenen Bestandteilen, die im Zusammenspiel Verarbeitung von Informationen ermöglichen. Folgende Komponenten sind zur Ausführung eines Programms wichtig.
\subsubsection{CPU}\label{subsubsec:cpu}
Die \gls{cpu} beschreibt den wichtigsten Prozessor eines Computers. Mithilfe einer komplexen Platinenstruktur führt er, den Anweisungen eines Programms folgend, Berechnungen durch. 
\paragraph{Register}
Wichtig für die Ausführung eines Programms sind Register. Register sind ``Speicherbereiche für Daten, auf die der Prozessor besonders schnell zugreifen kann''. \cite{RegisterWikipedia:online} Sie speichern zum Beispiel den Fortschritt der Ausführung eines Programms. Einige der wichtigsten Register sind folgende:
\begin{itemize}
	\item \textbf{\gls{eip}}: Befehlszeiger für die jetzige Instruktions-Adresse \cite{UsefulRe7:online}
	\item \textbf{\gls{esp}}: Stapelzeiger für die vorherige Adresse \cite{UsefulRe7:online}
	\item \textbf{\gls{ebp}}: Basiszeiger bei Funktionsaufruf, dient zur Referenzierung lokaler Variablen im Stack \cite{UsefulRe7:online}
	\item \textbf{\gls{sfp}}: Gesicherter Basiszeiger für das vorherige Stack Frame, dient zur Wiederherstellung des ursprünglichen Stack-Zustands \cite{UsefulRe7:online}
\end{itemize}

Die Bedeutung dieser Funktionen wird im Kapitel \nameref{subsec:funktionsweise-eines-programmes} (\ref{subsec:funktionsweise-eines-programmes}) genauer erklärt.
\subsubsection{RAM (Arbeitsspeicher)}
Das \gls{ram} ist ein elektronischer Computerspeicher, dessen Daten sehr schnell und in beliebiger Reihenfolge gelesen und geändert werden können. Er wird deshalb für Daten aktuell laufender Programme verwendet. Oft wird ein Vergleich zum menschlichen Kurzzeitgedächtnis hergestellt. 
\paragraph{Bit und Binärzahlen}
Computer sind nur imstande, Nullen (0) und Einsen (1) zu speichern, sie arbeiten also nur mit zwei Zuständen. Ein \gls{bit} beschreibt einen einzelnen solchen Zustand. Werden mehrere \glspl{bit} zur Datenspeicherung verwendet, steigt die Anzahl möglicher Kombinationen exponentiell auf \( 2^n \) (bei \(n = Anzahl~\glspl{bit}\)) \glspl{bit}. Zahlen werden folgendermassen gespeichert: Die Stelle in der Binärzahl von hinten (also rechts) beginnend dient als Exponent (startend bei null ) zur Basis 2. Bei einer 1 wird die Zahl zur Gesamtzahl addiert, bei 0 nicht. Die (dezimale) Zahl 21 zum Beispiel entspricht der Binärzahl 10101, da sie sich durch (von rechts nach links) \(1 \times 2^0 + 0 \times 2^1 + 1 \times 2^2 + 0 \times 2^3 + 1 \times 2^4 = 21\) zusammensetzt. Zur Konversion können Online-Rechner wie zum Beispiel \url{https://www.rapidtables.com/convert/number/} verwendet werden.

\paragraph{Big and Little Endian Byte Order}
Ein Byte umfasst acht Bits. Zur Ordnung von Bytes existieren zwei Strukturen: Big und Little Endian. Big Endian speichert das wichtigste, also signifikanteste Byte zuerst, während Little Endian dieses zuletzt speichert. Das signifikanteste Byte ist dasjenige, das den grössten Einfluss auf die Gesamtzahl hat, daher normalerweise das am weitesten links stehende.

\paragraph{Speicheradressen}
Jedes \gls{bit} im \gls{ram} ist einzeln adressierbar. Heutzutage arbeiten die meisten Computer mit 32bit oder 64bit Systemen. Dies entspricht der Adresslänge der Speicheradressen und limitiert somit die Anzahl adressierbarer \glspl{bit}. Bei 32bit ist die Ansteuerung von \(2^{32} = 4 294 967 296\) \glspl{bit} möglich, bei 64bit \(2^{64} = 18 446 744 073 709 551 616\). In der Praxis wird dies nur selten ausgereizt. Einfachheitshalber erfolgt die Angabe der Speicheradresse normalerweise im hexadezimalen Format (Basis 16). Dazu werden die Zeichen 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E und F verwendet. Ein Hexadezimalzeichen entspricht vier \glspl{bit} (da \(2^4 = 16\)), eine 32bit Adresse setzt sich also aus acht Hexadezimalstellen zusammen. Hexadezimalzahlen werden üblicherweise mit dem Präfix ``0x'' angekündet. Eine 32bit Speicheradresse könnte folgendermassen aussehen: 0xb7ec819b. \cite{BitWiki31:online}

\subsubsection{HDD/SSD}
Speichermedien, wie hauptsächlich \gls{hdd} und \gls{ssd}, dienen der permanenten Speicherung von Daten, also auch über den Neustart eines Systems hinaus. Ihr Lese- und Schreibzugriff ist langsamer als bei \gls{ram}, die Speicherkapazität dafür meist höher. Oft wird ein Vergleich zum menschlichen Langzeitgedächtnis hergestellt. 

\subsection{Funktionsweise eines Programms}\label{subsec:funktionsweise-eines-programmes}
Hacker schreiben Code, nutzen ihn aber auch aus. Ein Verständnis grundlegender Programmierkonzepte ist deshalb notwendig.
\subsubsection{Einführung}
``Ein Programm ist nichts anderes als eine Reihe von Anweisungen, die in einer bestimmten Sprache geschrieben sind.'' \texttt{(Erickson, 2008, S. 20, übersetzt mit DeepL)} \cite{erickson2008hacking} Es ist vergleichbar mit einem Küchenrezept. Genauso wie das Küchenrezept Menschen sagt, was sie tun sollen, sagt ein Programm dem Computer, was er zu tun hat. Im Gegensatz zu Menschen hat ein Computer aber keinen eigenen Willen und muss sich an die gegebenen Instruktionen halten. In dieser Arbeit liegt der Fokus exemplarisch auf der Programmiersprache C, da damit verbundene Hacking-Methoden beschrieben werden, die grundlegenden Konzepte können aber auf viele Programmiersprachen übertragen werden.
\subsubsection{Grundlagen}
Ein Programm besteht aus verschiedenen Elementen. Die wichtigsten Elemente werden im Folgenden beschrieben.

\paragraph{Kontrollstrukturen}
Kontrollstrukturen steuern den Ablauf eines Programms.
\begin{itemize}
	\item \textbf{If-then-else}: If-then-else-Strukturen erlauben die Ausführung eines Programmteiles nur unter bestimmten Bedingungen. Falls die Bedingung nicht erfüllt ist, wird der Programmteil übersprungen oder, wenn angegeben, ein alternativer Programmteil ausegführt.
	\item \textbf{While-Schleifen}: While-Schleifen wiederholen einen bestimmten Programmteil solange, bis eine Bedingung erfüllt ist. 
	\item \textbf{For-Schleifen}: For-Schleifen werden normalerweise gebraucht, um einen bestimmten Programmteil eine definierte Anzahl mal zu durchlaufen.
\end{itemize}

\paragraph{Variablen und Konstanen}
Variablen und Konstanten speichern Daten. Variablen sind veränderbar, während Konstanten über die Laufzeit eines Programmes unverändert bleiben. Im Folgenden wird einfachheitshalber von Variablen gesprochen, die beschriebenen Eigenschaften sind aber auch auf Konstanten übertragbar.

\begin{itemize}
	\item \textbf{Datentypen}: Bei Variablen wird zwischen verschiedenen Datentypen unterschieden. Einige Programmiersprachen sind bei der Handhabung flexibel und erlauben Veränderungen des Datentyps einer Variable, während andere Variablen bestimmte Datentypen zuordnen. Die Liste wichtigsten Datentypen:
	\begin{itemize}
		\item \textbf{String}: Text (``Hello'', ``World'')
		\item \textbf{Int}: Ganzzahl (2, 37)
		\item \textbf{Float}: Gleitkommazahl (3.1415, 2.7182)
		\item \textbf{Boolean}: Wahrheitswert (True, False)
		\item \textbf{Array}: Geordnete Liste mit festem Datentyp ([1, 3, 2, 8])
		\item \textbf{List}: Geordnete Liste mit gemischten Datentypen ([2, ``Hello'', True])
		\item \textbf{Dict}: Liste mit Schlüssel-Wert-Paaren ([``Mehl'': 500, ``Zitrone'': False])
	\end{itemize}
	\item \textbf{Gültigkeitsbereich und Lebensdauer}: Variablen sind je nach Initialisierung (Erstellung) nur für bestimmte Teile eines Programms zugänglich. Wird eine Variable beispielsweise in einer Funktion initialisiert, existiert sie nur während der Funktionsausführung. Variablen besitzen folgende Gültigkeitsbereiche:
	\begin{itemize}
		\item \textbf{Globale Variablen}: Zugänglich vom gesamten Programm
		\item \textbf{Lokale Variablen}: Zugänglichkeit auf Funktion oder Programmteil limitiert
		\item \textbf{Statische Variablen}: Zugänglichkeit auf Funktion limitiert, behalten jedoch Wert bei erneutem Funktionsaufruf
	\end{itemize}
	Die verschiedenen Gültigkeitsbereiche führen dazu, dass gleichnamige Variablen mehrere Speicheradressen haben können. In einigen Programmiersprachen müssen Variablen vor der ersten Verwendung initialisiert, also angekündigt, werden. 
\end{itemize}

\paragraph{Arithmetische Operatoren}
Arithmetische Operatoren werden verwendet, um mathematische Operationen durchzuführen. In C stehen die unten aufgelisteten Operatoren zur Verfügung:
\begin{itemize}
	\item \textbf{Addition (+)}: 2 + 3 = 5
	\item \textbf{Subtraktion (-)}: 5 - 3 = 2
	\item \textbf{Multiplikation (*)}: 5 * 3 = 15
	\item \textbf{Division (/)}: 15 / 3 = 5
	\item \textbf{Modulus (\%)}: 15 \% 4 = 3 ((positiver) Rest der Division)
	\item \textbf{Inkrement (++)}: a++ = a + 1
	\item \textbf{Dekrement (--)}: a-- = a - 1
	\item \textbf{Exponentiation (pow())}: pow(a, 3) = $a^3$
\end{itemize}
Für einige Operatoren können Gleichungen, deren Resultat-Variable auch in der Berechnung vorkommt, abgekürzt werden. Statt \(a = a + 5\) lässt sich beispielsweise \(a \text{ += } 5\) schreiben.

\paragraph{Vergleichsoperatoren}
Vergleichsoperatoren dienen dem Vergleich von Variablen oder Werten. Sie geben jeweils True oder False aus. Folgende Operatoren können verwendet werden:
\begin{itemize}
	\item \textbf{Gleichheit (==)}: 5 == 5 $\rightarrow$ True
	\item \textbf{Ungleichheit (!=)}: 5 != 3 $\rightarrow$ True
	\item \textbf{Größer als (>) }: 5 > 3 $\rightarrow$ True
	\item \textbf{Kleiner als (<)}: 5 < 3 $\rightarrow$ False
	\item \textbf{Größer oder gleich (>=)}: 5 >= 5 $\rightarrow$ True
	\item \textbf{Kleiner oder gleich (<=)}: 3 <= 5 $\rightarrow$ True
\end{itemize}

\paragraph{Funktionen}
Funktionen dienen zur Wiederholung bestimmter Programmteile. Sie erlauben einen In- und Output. Der arithmetische Operator pow() ist beispielsweise eine Funktion. Sie erlaubt den Input von \texttt{base} und \texttt{exponent} und gibt die Potenz der beiden Zahlen zurück. Eine Potenz-Funktion für Ganzzahlen könnte so aussehen:
\begin{lstlisting}
	int pow(int base, int exponent) {
		int result = 1; // Startwert für die Multiplikation
		for (int i = 0; i < exponent; i++) {
			result *= base; // Multiplikation
		}
		return result;
	}
\end{lstlisting}

\paragraph{Dateizugriff}
Dateien, die permanent auf einem Speichermedium gespeichert sind, können gelesen, bearbeitet und ausgeführt werden. Ein Benutzer kann dabei aber nur diejenigen Operationen verwenden, deren Rechte er besitzt. Die Identifikation des Benutzers erfolgt über eine ID (beispielsweise 999).

\paragraph{Pseudo-Zufallszahlen}
Bei bestimmten Anwendungen, wie zum Beispiel der Simulation eines Wettermodells oder einem Computerspiel, werden Zufallszahlen benötigt. Computer sind nicht in der Lage, zufällige Zahlen zu generieren. Hauptsächlich wird deshalb auf zwei Alternativen zurückgegriffen: Bei der ersten Möglichkeit werden mathematische Operationen verwendet, die zufällig aussehen. Eine bekannte Methode ist beispielsweise das Quadrieren zehnstelliger Dezimalzahlen. Vom Resultat werden die mittleren zehn Ziffern als neue Zufallszahl angesehen. Eine zweite Möglichkeit ist die Verwendung unvorhersehbarer Prozesse. Dabei wird aus unvorhersehbaren Prozessen wie dem atmosphärischen Rauschen Zahlen generiert.~\cite{Mathemat11:online}

\subsubsection{Abstraktions-Ebenen}
Computer können nur mit aus Einsen und Nullen bestehender Maschinensprache umgehen. Da die Programmierung in Maschinensprache sehr aufwendig und unintuitiv ist, wurden verschiedene Abstraktions-Ebenen eingeführt.

\paragraph{Höhere Programmiersprache (High Level Language)}
Höhere Programmiersprache liegt nahe bei der englischen Sprache und ist (zumindest in Grundzügen) für die meisten Leute intuitiv verständlich. Normalerweise wird in höherer Programmiersprache programmiert. Das Beispiel der Potenz-Funktion oben ist in höherer Programmiersprache angegeben.
\paragraph{Maschinensprache (Machine Language)}
Maschinensprache besteht nur aus Einsen und Nullen und ist auch für die meisten professionellen Programmierer unverständlich. Der Code \(x = 3 + 5\) könnte (bei Angabe im hexadezimalen Format) so aussehen: 
\begin{lstlisting}[style=LowLevelStyle]
	b8 05 00 00 00
	83 c0 03 
\end{lstlisting}
\paragraph{Assemblersprache (Assembly Language)}
Assemblersprache kann als die Verbalisierung der Maschinensprache angesehen werden und wird teilweise zur Programmierung verwendet. Dies aber nur bei sehr systemnahen Anwendungen. Derselbe Code \(x = 3 + 5\) könnte in Assemblersprache so aussehen: 
\begin{lstlisting}[style=LowLevelStyle]
	mov 	eax, 5
	add 	eax, 3
\end{lstlisting}

Hier werden auch die in Kapitel~\ref{subsubsec:cpu} erwähnten Register ersichtlich.

Zur Übersetzung zwischen den Abstraktionsebenen dienen der Compiler und Assembler. Der Compiler transformiert höhere Programmiersprache in Maschinensprache, der Assembler Assemblersprache in Maschinensprache.

\subsubsection{Ablauf zur Ausführung}
Die Ausführung eines Programms folgt folgendem Grundprinzip:
\begin{enumerate}
	\item Der Code wird kompiliert (oder assembliert) und als Maschinencode im RAM gespeichert.
	\item Die Instruktion, zu der das \gls{eip}-Register zeigt, wird gelesen.
	\item Die Bitlänge der Instruktion wird zum \gls{eip} addiert, der \gls{eip} zeigt jetzt also zur nächsten Instruktion.
	\item Die Instruktion wird ausgeführt.
	\item Neustart bei Schritt 2.
\end{enumerate}

\subsubsection{Speichersegmentierung in C}
Die Datenanordnung im RAM folgt einer bestimmten Struktur. Bei C wird sie in fünf Segmente aufgeteilt.
\begin{itemize}
	\item \textbf{Text Segment}: Speichert Code (in Maschinensprache), ist unveränderlich
	\item \textbf{Initialized Data}: Speichert initialisierte globale und statische Variablen
	\item \textbf{Uninitialized Data}: Speichert uninitialisierte Variablen
	\item \textbf{Heap Segment}: Ist kontrollierbar durch den Programmierer, wächst von niedrigen zu hohen Adressen~\cite{StackHeapYoutube:online}
	\item \textbf{Stack Segment}: Speichert den Kontext und lokale Variablen bei Funktionsaufrufen, funktioniert nach LIFO-Prinzip (last-in-first-out): wächst von hohen zu niedrigen Adressen und wird umgekehrt abgearbeitet~\cite{StackHeapYoutube:online}
\end{itemize}
Unter dem Stack werden Umgebungsvariablen und Befehlszeilenargumente gespeichert. Umgebungsvariablen enthalten Information zur Umgebung des Systemes~\cite{UmgebungsMicrosoft:online} und Befehlszeilenargumente sind vom Benutzer beim Programmstart eingegebene Daten.

\paragraph{Stack Frame}
Ein Stack Frame ist ``ein Abschnitt des Stacks, der einem bestimmten Funktionsaufruf gewidmet ist.''~\texttt{(NordVPN, Dezember 2024, übersetzt mit DeepL)}\cite{StackFrameNordVPN:online} Das Stack Frame der aufgerufenen Funktion wird oberhalb des Stack Frame der aktuellen Funktion erstellt und enthält alle wichtigen Informationen. Dazu gehören unter anderem Variablen, der \gls{ebp} und die Rückkehradresse. Die Rückkehradresse wird benötigt, um an der richtigen Stelle zur ursprünglichen Funktion zurückzukehren.

\subsection{Funktionsweise eines Netzwerks}
Viele Hacking-Attacken nutzen Schwachstellen in Netzwerken aus. Für Hacker sind Netzwerk-Attacken sehr attraktiv, da sie keinen physischen Zugriff auf Infrastruktur erfordern.
\subsubsection{Einführung}
Ein Netzwerk ist ein ``großes System, das aus vielen ähnlichen Teilen besteht, die miteinander verbunden sind, um eine Bewegung oder Kommunikation zwischen den Teilen oder zwischen den Teilen und einem Kontrollzentrum zu ermöglichen.''~\texttt{(Cambridge University Press, Dezember 2024, übersetzt mit DeepL)} Anwendungen wie das \gls{www} oder WhatsApp-Nachrichten basieren auf einer Netzwerkstruktur. Ein Netzwerk ist aber nicht dem Internet gleichzusetzen und kann auch lokal existieren. naja

\subsubsection{OSI-Modell}\label{subsubsec:osimodell}
Das \gls{osi}-Modell standardisiert den Netzwerkverkehr und bietet damit die Grundlage der Datenübertragung. Das Modell wurde in in den 1980er-Jahren von der \gls{iso} entwickelt und ist heute mehrheitlich von dem \gls{tcp}/\gls{ip}-Modell abgelöst, wird wegen besserer Übersichtlichkeit aber oft zu Unterrichtszwecken verwendet.~\cite{OSImodelWikipedia:online}
\paragraph{Einführung}
Das \gls{osi}-Modell ist in sieben Ebenen mit jeweils spezifischen Funktionen zum Datentransport organisiert. Ebene sieben ist dabei am nächsten bei der Anwendung, während Ebene eins am nächsten bei der physischen Hardware liegt. Bevor Daten transportiert werden, werden sie bei Ebene sieben beginnend in alle Ebenen verpackt. Beim Erhalt werden sie wieder entpackt. Zwischengeräte wie Router, die für die Weiterleitung der Datenpakete verantwortlich sind, packen die Daten nur soweit, wie für die Weiterleitung nötig, aus. Meist entspricht dies Ebene drei. Datenpakete bestehen aus einem Header und Daten. Der Header enthält wichtige Informationen zum Datentransport, so zum Beispiel die Datenlänge oder die Senderadresse. 
\paragraph{Netzwerkprotokolle}
Netzwerkprotokolle standardisieren die Struktur eines Datenpaketes. Sie sind für die korrekte Formatierung der Daten verantwortlich und bestimmen den Inhalt des Headers. Damit ermöglichen sie verschiedenen Geräten eine einheitliche Kommunikationsbasis. Jedem Netzwerkprotokoll ist ein Port zugewiesen. Ein Port ist eine ``softwaredefinierte Nummer, die einem Netzwerkprotokoll zugeordnet ist und Kommunikation für einen bestimmten Dienst empfängt oder überträgt.''~\cite{WasistPo:online} Die Auflistung der sieben Ebenen weiter unten bietet einige Beispiele verschiedener Netzwerkprotokolle.
\paragraph{Die sieben Ebenen}
Im Anschluss findet sich eine Auflistung der sieben Ebenen. Wichtige Eigenschaften oder Protokolle einer Ebene werden untergeordnet angegeben.
\begin{itemize}
	\item \textbf{1. Bitübertragung}: Verantwortlich für die physische Verbindung zwischen zwei Punkten, überträgt einzelne \glspl{bit} (zum Beispiel Ethernet-Kabel, Bluetooth)
	\item \textbf{2. Sicherung}: Zuständig für zuverlässige Übertragung der Daten inklusive Fehlerkorrektur und Flusskontrolle.
	\begin{itemize}
		\item \gls{mac}-Adressen: Hardware-Adressen, werden zur Kommunikation auf Level 2 benötigt. Normalerweise (im Gegensatz zur \gls{ip}-Adresse) gerätespezifisch.
		\item \gls{arp}: Wandelt \gls{ip}-Adressen (Level 3) in \gls{mac}-Adressen (Level 2) um. Dazu sendet es Anfrage mit einer \gls{ip}-Adresse an die Broadcasting-Adresse eines Netzwerkes (Adresse, die alle Geräte in einem Netzwerk umfasst). Das Gerät mit entsprechender \gls{ip}-Adresse antwortet mit seiner \gls{mac}-Adresse.
	\end{itemize}
	\item \textbf{3. Vermittlung}: Entscheidet über den Pfad der Daten, kümmert sich um die Fragmentierung (Aufteilung von Datenpaketen bei Überschreitung der maximalen Datenmenge).
	\begin{itemize}
		\item \gls{ip}-Adresse: Wird jedem internetfähigen Gerät zugewiesen wird und zur Kommunikation auf Level 3 benötigt.
		\item \gls{icmp}: Meldet Fehler und führt Netzdiagnosen durch. Das \texttt{ping}-Kommando testet beispielsweise die Verbindung zwischen zwei Geräten.~\cite{ICMPFortinet:online}
	\end{itemize}
	\item \textbf{4. Transport}: Sorgt für Ende-zu-Ende-Kommunikation zwischen Anwendungen. Hauptsächlich werden zwei Protokolle verwendet.
	\begin{itemize}
		\item \gls{udp}: Einseitiges, verbindungsloses, unzuverlässiges, aber ressourcenschonendes Protokoll, dass für zeitkritische Datenübertragung geeignet wie Videostreaming oder Online-Gaming geeignet ist.
		\item \gls{tcp}: Zweiseitiges, verbindungsbasiertes, zuverlässiges, dafür ressourcenintensives Protokoll, dass für Anwendungen mit hoher Datenintegrität wie Dateiübertragungen, E-Mails oder Webinhalte geeignet ist.
	\end{itemize}
	\item \textbf{5. Kommunikation}: Verwaltet Verbindungen durch Erstellung, Aufrechterhaltung und Auflösung.
	\item \textbf{6. Darstellung}: Formatiert und ver- oder entschlüsselt Daten für die Endanwendung.
	\item \textbf{7. Anwendung}: Schnittstelle einer Anwendungen zum Netzwerk.
	\begin{itemize}
		\item \gls{http} und \gls{https}: Kommunikationsprotokolle für das \gls{www}. \gls{https} ist im Gegensatz zu \gls{http} verschlüsselt.~\cite{HTTPWiki6:online, HTTPvers49:online} Die wichtigsten Anfrage-Methoden sind folgende:
		\begin{itemize}
			\item GET: Fordert spezifische Ressource an.
			\item HEAD: Fordert nur Header ohne Kontext an.
			\item POST: Sendet Daten an Server.
		\end{itemize}
		\item \gls{dns}: Protokoll zur Umwandlung von Hostnamen wie \url{www.google.com} in \gls{ip}-Adressen.
		\item \gls{pop3}: Veraltetes Protokoll zum Senden und Empfangen von E-Mails.~\cite{Pop3microsoft:online}
	\end{itemize}
\end{itemize}

\subsubsection{Sockets}
Sockets dienen als Endpunkte einer Verbindung und werden vom Betriebssystem bereitgestellt.~\cite{SocketW33:online} Sie operieren hauptsächlich auf Level 4. Sockets werden anhand von drei Eigenschaften unterschieden
\paragraph{Domain}
Die Domain legt fest, wie Adressen angegeben werden. Mögliche Optionen sind sind zum Beispiel \gls{ip} (Version 4) (\texttt{AF\_INET}) oder Bluetooth (\texttt{AF\_BLUETOOTH}).
\paragraph{Typ}
Drei Typen von Sockets existieren: Stream Sockets, Datagram Sockets und raw sockets. Normalerweise werden Stream Sockets mit dem \gls{tcp} benutzt, währenddessen Datagram Sockets das \gls{udp} verwenden. Dies führt auch zu den jeweiligen Eigenschaften: Stream Sockets sind zuverlässig aber langsam, Datagram Sockets schnell aber unzuverlässig. Raw Sockets erlauben die Miteinbeziehung und Analyse von tiefer liegenden Netzwerkebenen. 
\paragraph{Protokoll}
Das Protokoll spezifiziert, welches Protokoll auf Ebene vier verwendet werden sollte. Im Normalfall muss dies nicht explizit angegeben werden, da das System standardmässig das zum Typ des Sockets passende Protokoll auswählt.




\newpage
\section{Methoden und Techniken}\label{sec:methoden-und-techniken}
Hacking-Attacken sind sehr unterschiedlich und fokussieren sich auf verschiedene Bereiche eines Computersystems. Einige erfordern physischen Zugriff auf ein System während andere über ein Netzwerk erfolgen. Dieses Kapitel zeigt exemplarisch einige gut verständliche Hacking-Methoden und Techniken auf. Die Kapitel folgen jeweils derselben Struktur: Zuerst wird die allgemeine Funktionsweise einer Attacke beschrieben und danach auf die Abwehrmechanismen eingegangen. In einigen Kapiteln findet sich auch ein konkretes Beispiel mit Code. Zuletzt folgt ein Kapitel mit Erklärungen zu bekannten Begriffen, die bis dahin noch nicht erklärt wurden. \\Wie am Anfang bereits erwähnt, diente, sofern keine andere Quelle angegeben wurde, das Buch ``Hacking - The Art of Exploitation''~\cite{erickson2008hacking} als Hauptquelle dieses Kapitels. Einige Beispiele wurden direkt aus dem Buch übernommen. Diese sind so gekennzeichnet.

\subsection{Buffer Overflow}\label{subsec:buffer-overflow}
Ein Buffer beschreibt einen reservierten Speicherbereich, um Daten temporär zu speichern. Ein Buffer Overflow tritt auf, wenn mehr Daten in diesen Bereich geschrieben werden, als die Kapazität erlaubt. Dies kann dazu führen, dass zur Ausführung des Programms wichtige Daten überschrieben werden und das Programm anders abläuft, als vom Programmierer ursprünglich geplant. Dies ist besonders kritisch, wenn das Programm mit Root-, also Administrationsrechten ausgeführt wird, da der Angreifer dann die Kontrolle über das gesamte System erlangen kann. Programmiersprachen wie C, bei denen sich \gls{ram} sehr direkt kontrollieren lässt, sind besonders anfällig für Attacken dieser Art. Moderne Programmiersprachen besitzen oft eine automatische Speicherverwaltung, die die direkte Kontrolle des \gls{ram} erschweren oder sogar verunmöglichen.

\subsubsection{Allgemeine Funktionsweise}
Voraussetzung dieser Attacke ist ein Programm, das Daten (zum Beispiel Text) als Input annimmt und diese in das \gls{ram} kopiert, ohne vorher zu überprüfen, ob ausreichend Platz reserviert wurde. Der Angreifer kann den Input dann bewusst zu lange wählen, so dass er die Kapazität des buffers überschreitet. Ziel ist oft die Überschreibung der Rückkehradresse einer Funktion. Diese liegt unterhalb des Buffers im Stack Frame. Da Daten im Stack in Richtung tiefer Adressen gespeichert werden, wird die Rückkehradresse ab einer bestimmten Inputlänge überschrieben. Bei geschickter Zeichenfolge wird sie durch eine neue Speicheradresse ersetzt, die auf einen eigens im \gls{ram} platzierten Code zeigt. Dieser oft bösartige Code wird als Shellcode bezeichnet. Er muss in Assembler- oder Maschinensprache angegeben werden. Zur Platzierung des Shellcodes im \gls{ram} können verschiedene Methoden verwendet werden. In diesem Fall wird er als Input eingegeben, die Platzierung in Umgebungsvariablen ist beispielsweise aber auch möglich, erfordert aber deren Zugriff. \\Der zur Ausführung dieser Attacke nötige Input enthält also eine neue Rückkehradresse und den Shellcode. Die Rückkehradresse zeigt dabei zur Speicheradresse des Shellcodes und lässt diesen bei Funktionsende ausführen. Zwei Probleme treten auf:
\begin{enumerate}
	\item Meist ist es schwer vorherzusagen, wo genau die neue Rückkehradresse im Input platziert werden muss, damit sie die originale Rückkehradresse trifft. Die Speichersegmentierung kann zwischen Programmausführungen variieren und lässt eine exakte Vorhersage nur schwer zu. Dieses Problem kann einfach durch die wiederholte Angabe der neuen Rückkehradresse gelöst werden. Wenn man statt nur eine anzugeben einen ganzen Bereich mit Rückkehradressen füllt, erhöht sich die Wahrscheinlichkeit, die originale Rückkehradresse zu treffen, massiv.
	\item Das zweite Problem bezieht sich auf die Vorhersage der Speicheradresse des Shellcodes. Da eine exakte, genau auf den Start des Shellcodes zeigende Rückkehradresse angegeben werden muss, kann das Problem nicht durch wiederholte Angabe gelöst werden. Hier greift man auf einen \gls{nop} sled zurück.
	\paragraph{NOP sled}
	Ein \gls{nop} sled beschreibt eine Reihe von \gls{nop}-Instruktionen. Diese Instruktionen tun nichts, ausser zur nächsten Instruktion zu springen, bis schliesslich der finale Code (in diesem Fall Shellcode) erreicht wird.
	
	Die Platzierung eines langen \gls{nop} sled vor dem Shellcode macht eine genaue Vorhersage der Speicheradresse des Shellcodes überflüssig. Es reicht, wenn die Rückkehradresse den \gls{nop} sled trifft.
\end{enumerate}

Der finale Input hat dementsprechend folgendes Format (RET für Rückkehradresse):
\newline
\begin{center}
	\centerline{| NOP | NOP | NOP | SHELLCODE | RET | RET | RET |}
\end{center}
Er führt zur Ausführung des Shellcodes.

\subsubsection{Abwehrmechanismen}\label{subsubsec:abwehrbuffer-overflow}
Bei modernen Computersystem ist diese Attacke wegen verschiedener Sicherheitsmechanismen relativ schwierig durchzuführen.

\begin{itemize}
	\item \textbf{Bound-Checking}: Die simpelste Abwehrmethode ist das Bound-Checking. Sie verhindert das Schreiben von Daten bei Überschreitung der Kapazität eines Buffers.
	\item \textbf{Stack Canaries}: Stack Canaries beschreiben eine Methode, bei der bewusst Prüfdaten im \gls{ram} platziert werden, die nicht zur Veränderung gedacht sind. Eine Veränderung dieser Daten hat eine Alarmierung des Systems zur Folge.~\cite{StackCan84:online}
	\item \textbf{\gls{aslr}}: \gls{aslr} ordnet ausführbarem Code zufällige Adressen zu. Dies erschwert auch die ungefähre Vorhersage von Datenplatzierung im \gls{ram}.~\cite{Whatisad68:online}
	\item \textbf{Non-Executable Memory}: Gewisse Speicherbereiche im \gls{ram} werden als nicht ausführbar markiert. Wird der Shellcode in einem dieser Bereiche platziert, ist er nutzlos.
\end{itemize}


\subsubsection{Konkretes Beispiel}\label{subsubsec:bspbuffer-overflow}
\textit{Dieses Beispiel inklusive Code wurde direkt aus dem Buch ``Hacking - The Art of Exploitation''~\cite{erickson2008hacking} übernommen. Es kann selbst nachgestellt werden. Zur Handhabung der Beispiele und Links zum Code siehe Kapitel \nameref{subsec:beispiele} im Appendix. Als Ver­ständ­nis­hil­fe wurde zusätzlich zum Buch wurde ein Stack Overflow-Eintrag verwendet.~\cite{stacko:online}}

Voraussetzung für die Durchführung dieses Beispiels ist ein 32bit Linux System, bei welchem die oben angegebenen Abwehrmechanismen nicht vorhanden oder deaktiviert sind. Für das Beispiel werden folgende Programme verwendet:

\begin{itemize}
	\item \textbf{notetaker.c}: Ein Notizprogramm, das Notizen in einer Datei (var/notes) speichert. Da das Programm von mehreren Benutzern benutzt werden können soll, gehört es root.
	\item \textbf{notesearch.c}: Ein Programm, das die Notizen einer bestimmten Person wiedergibt und einen Suchinput zulässt. Es gehört ebenfalls root. Das Programm hat eine Sicherheitslücke (im Programmausschnitt unten in Linie 5). Es kopiert den Suchstring, der als erstes Befehlszeilenargument eingegeben werden kann, ohne Überprüfung der Länge in den auf 100 Bytes limitierten Buffer. Dies geschieht durch die Funktion \texttt{strcpy()}.
	\begin{lstlisting}
		int main(int argc, char *argv[]) {
			int userid, printing=1, fd;
			char searchstring[100];
			if(argc > 1)
				(*@\textbf{strcpy(searchstring, argv[1]);}@*)
			else
				searchstring[0] = 0;
		\end{lstlisting}
	\item \textbf{exploit\_notesearch.c}: Dieses Programm wird zur Erstellung des präparierten Suchstrings verwendet. Die Funktionsweise wird im Folgenden genauer erläutert. Das Programm ist im Anhang abgedruckt.
\end{itemize}

\paragraph{Erstellung des Suchstrings}
Zur ungefähren Abschätzung der Speicheradresse der Speicheradresse des Suchstring-Buffers wird eine Variable des \textbf{exploit\_notesearch.c}-Programmes zur Hilfe genommen, dessen Adresse sich während der Ausführung abfragen lässt. Es kann davon ausgegangen werden, dass \textbf{notesearch.c}-Programm ähnliche Speicheradressen verwendet, da der Prozess ungefähr an derselben Stelle gestartet wird. Experimentieren ist aber nötig, weshalb ein \texttt{offset}-Wert definiert wird, der eine Verschiebung der Speicheradressen ermöglicht. Anhand dieser Daten wird ein Suchstring nach obigem Format erstellt. Der Shellcode öffnet in diesem Fall eine Root-Kommandozeile.

\paragraph{Ausführung von notesearch.c}
Das Programm wird mit dem präparierten Suchstring gestartet. Dabei wird ein Skript verwendetet, welches systematisch verschiedene \texttt{offset}-Werte ausprobiert. Falsche \texttt{offset}-Werte bringen das \textbf{notesearch.c}-Programm in den meisten Fällen zum Absturz. Sobald der richtige \texttt{offset}-Wert gefunden wurde, wird die Attacke erfolgreich durchgeführt und eine Kommandozeile geöffnet. Durch das Kommando \texttt{whoami} lässt sich überprüfen, dass die Kommandozeile Root-Berechtigungen besitzt. 


\subsection{Format String Exploitation}
In den meisten Programmiersprachen gibt es Möglichkeiten, Text in die Kommandozeile zu drucken. Für variablen Input werden in C Format Specifiers gebraucht. Format Specifiers geben an, welcher Datentyp erwartet werden soll. Beispielsweise kann der Format Specifier \texttt{\%d} für Ganzzahlen auf diese Weise eingesetzt werden: 
\begin{lstlisting}
	int main() {
		int zahl = 42;
		printf("Ganzzahl: %d", zahl);  
	}
\end{lstlisting}
Die Ausgabe des Programms lautet:
\begin{lstlisting}[style=COutputStyle]
	Ganzzahl: 42
\end{lstlisting}

Eine fehlerhafte Implementierung von Format Specifiers kann ausgenutzt werden, um unerwünschte Speicherzugriffe oder -manipulationen durchzuführen. 

\subsubsection{Allgemeine Funktionsweise}
Voraussetzung dieser Attacke ist ein Programm, welches eine Angabefunktion wie \texttt{prinf()} verwendet, um vom Benutzer gegebenen Input zu drucken. Dabei wird der Input aber nicht explizit als String, sondern direkt gedruckt (siehe Code unten).
\begin{lstlisting}
	printf("%s", text); // korrekte Art
	printf(text);  // falsche Art
\end{lstlisting}

Die falsche Implementierung erlaubt dem Angreifer die Benutzung von eigenen Format Specifiers. Zum Verständnis der Attacke muss die Speichersegmentierung bei einem \texttt{printf()}-Funktionsaufruf bekannt sein. 

\paragraph{Speichersegmentierung bei printf()}
Bei Funktionsaufruf einer \texttt{printf()}-Funktion wird eine Rückkehradresse zur Ursprungsfunktion, die Speicheradresse im Text Segment des zu druckenden Textes und die Argumente der \texttt{printf()}-Funktion in dieser Reihenfolge auf den Stack gelegt. Die Argumente stehen jeweils direkt hintereinander. Je nach Datentyp werden die Werte direkt, also nicht als Referenzierung durch Speicheradressen, auf den Stack gelegt. Beim Format Specifier \texttt{\%x}, der aus vier Bytes bestehende hexadezimale Zahlen in den Text einbettet, ist dies der Fall. 

Die Falsche Implementierung der \texttt{printf()}-Funktion kann auf zwei Arten ausgenutzt werden:
\begin{enumerate}
	\item \textbf{Speicherlesen}: Format Specifier wie beispielsweise \texttt{\%x} erwarten Argumente. Werden keine Argumente angegeben, lesen sie die Daten an der Stelle aus, an der die Argumente erwarten werden. Durch Wiederholung von \texttt{\%x} lassen sich so ab der Stelle, bei der die \texttt{printf()}-Funktion Argumente im \gls{ram} erwartet, Daten in die Kommandozeile drucken. Dies erlaubt das vom Programmierer möglicherweise unerwünschte Auslesen von Daten.
	\item \textbf{Speichermanipulation}: Bedeutend schlimmer ist die unerwünschte Veränderung von Daten im \gls{ram}. Dazu kann der Format Specifier \texttt{\%n} genutzt werden. Er schreibt die bisherige Anzahl gedruckter Zeichen als Binärzahl an eine als Argument angegebene Speicheradresse. Das Beispiel unten zeigt die Funktionalität von \textit{\%n}. Der Referenzoperator \texttt{\&} wird benötigt, um die Variable \texttt{count} zu referenzieren. Dies ist erforderlich, da \texttt{\%n} eine Speicheradresse erwartet.
	\begin{lstlisting}
		int main() {
			int count;
			printf("Hallo, Welt!%n", &count);
			printf("\nAnzahl der ausgegebenen Zeichen: %d", count); 
		}
	\end{lstlisting}
	Die Ausgabe des Programms lautet:
	\begin{lstlisting}[style=COutputStyle]
		Hallo, Welt!
		Anzahl der ausgegebenen Zeichen: 12
	\end{lstlisting}
	Diese Attacke ist speziell kritisch, wenn der gedruckte Text weiter unten im Stack gespeichert wird und so auf sich selbst referenzieren kann, denn dadurch können gezielt Speicheradressen manipuliert und durch geschickte Wahl des Input mit eigenen Daten gefüllt werden. Das Beisiel in Kapitel \ref{subsubsec:bspprintf} demonstriert das Schreiben einer eigenen Speicheradresse an einen bestimmten Punkt im \gls{ram}. Mithilfe eines Shellcodes kann dies dieselben Konsequenzen wie eine Buffer Overflow-Attacke (Kapitel \ref{subsec:buffer-overflow}) von sich tragen.
\end{enumerate}

\subsubsection{Abwehrmechanismen}
Erneut ist die Attacke bei modernen Computersystemen wegen verschiedenen Abwehrsystemen nur schwer durchzuführen.

\begin{itemize}
	\item \textbf{Drucken als String}: Wird der Input mit dem Format Specifier \textit{\%s} als String gedruckt, werden in ihm enthaltene Format Specifier ignoriert. 
	\item \textbf{Stack Canaries, \gls{aslr} und Non-Executable Memory}: Die Sicherheitsmechanismen, die bereits in Kapitel \ref{subsubsec:abwehrbuffer-overflow} beschrieben wurden, schützen auch in diesem Fall vor ungewollten Änderungen im \gls{ram} oder der Ausführung des Shellcodes.
\end{itemize} 

\subsubsection{Konkretes Beispiel}\label{subsubsec:bspprintf}
\textit{Dieses Beispiel inklusive Code wurde direkt aus dem Buch ``Hacking - The Art of Exploitation''~\cite{erickson2008hacking} übernommen. Es kann selbst nachgestellt werden. Zur Handhabung der Beispiele und Links zum Code siehe Kapitel \nameref{subsec:beispiele} im Appendix.}

Voraussetzung für die Durchführung dieses Beispiels ist ein 32bit Linux System, bei welchem die oben angegebenen Abwehrmechanismen nicht vorhanden oder deaktiviert sind. Für das Beispiel wird das Programm \textbf{fmt\_vuln.c} verwendet. 

\paragraph{fmt\_vuln.c}
Das Programm \textbf{fmt\_vuln.c} druckt einen vom Benutzer als Kommandozeilenargument gegebenen Input in die Kommandozeile. Die Sicherheitslücke besteht darin, dass das Programm den Text nicht explizit als String, sondern direkt druckt. Die zwei wichtigsten Zeilen sind unten abgedruckt.

\begin{lstlisting}
	strcpy(text, argv[1]);
	prinft(text);
\end{lstlisting} 
Eine weitere wichtige Eigenschaft des Programms ist, dass der \texttt{text}-Buffer, der den vom Benutzer gegebenen Input speichert, unterhalb (bei höheren Speicheradressen) des \texttt{printf()}-Stack Frame im Stack gespeichert ist. Die Angabefunktion muss auf dem höchsten Stack Frame sein, die Speicherung des \texttt{text}-Buffers muss also unterhalb geschehen. Dies macht eine Selbstreferenzierung möglich.

Zu Demonstrationszwecken wird der Wert einer Variable \texttt{test\_val} mit einer Speicheradresse überschrieben. Analog zu Kapitel \ref{subsubsec:bspbuffer-overflow} kann die in diesem Kapitel beschriebene Technik aber zur Überschreibung einer Rückkehradresse und Ausführung von Shellcode verwendet werden. Eine gekürzte Version des Programm \textbf{fmt\_vuln.c} ist im Anhang abgedruckt. 

Zur Ausführung der Attacke sind folgende Schritte notwendig:
\begin{enumerate}
	\item Durch Ausprobieren mit wiederholter Angabe des Format Specifiers \texttt{\%x} lässt sich herausfinden, das wievielte Argument dem Beginn des \texttt{text}-Buffer entspricht. In diesem Fall ist es das vierte. 
	\item Ein geschickter Input wird eingegeben. Dieser hat folgendes Format:
	\newline
	\begin{center}
		\centerline{| S1 | JUNK | S2 | JUNK | S3 | JUNK | S4 | \%x | \%x | \%125x | \%n | \%201x | \%n | \%15x | \%n | \%175x | \%n |}
	\end{center}
	\begin{itemize}
		\item \textbf{Speicheradressen (S)}: S1, S2, S3 und S4 stehen für die vier einzelnen Bytes der \texttt{test\_val}-Variable. S1 zeigt zum ersten Byte, S4 zum letzten.
		\textbf{JUNK}: Das Wort JUNK wird als Platzhalter verwendet, von dem die \texttt{\%x} Format Specifier lesen können. Die Zeichenfolge ist nicht von Bedeutung und kann ersetzt werden, das Wort muss jedoch eine Länge von vier Bytes aufweisen.
		\item \textbf{\%x}: Die \texttt{\%x} Format Specifier lesen hexadezimale Wörter der Länge vier Bytes und betten diese in den Text ein. Eine Zahl vor dem \texttt{x} gibt die Mindestlänge der zu lesenden Daten an. Mithilfe der Mindestlänge kann die Anzahl der bisher geschriebenen Zeichen auf die gewünschte Länge erhöht werden.
		\item \textbf{\%n}: Die \texttt{\%n} Format Specifier schreiben die Anzahl bisher geschriebenen Zeichen als Integer der Länge vier Bytes an die als Argumente angegebenen Speicheradressen. Bei korrekter Anpassung des Inputs verwenden sie S1, S2, S3 und S4. 
	\end{itemize}
	Die ersten drei \texttt{\%x} Format Specifier werden gebraucht um die Distanz zum \texttt{text}-Buffer zu überwinden. Der dritte Format Specifier erhöht die Anzahl gedruckter Zeichen um 125. Diese Anzahl wird dann durch den \texttt{\%n} Format Specifier an die Speicheradresse S1 geschrieben. Da das am wenigsten signifikante Byte wegen der Little Endian Architektur zuerst gespeichert wird, wird das Byte an Stelle S1 mit der Anzahl gespeicherter Zeichen überschrieben. Der nächste Format Specifier erhöht die Anzahl gedruckter Zeichen erneut um die gewünschte Anzahl, in diesem Fall um 201. Sollte das zweite Byte der Speicheradresse tiefer sein als das erste ergibt sich ein Problem, da nur Erhöhung, nicht aber Vertiefung der bisher gedruckten Zeichen möglich ist. Dies lässt sich durch das Wrapping Around-Prinzip lösen. 
	\paragraph{Wrapping Around}
	Ein Byte entspricht einem Zeichen bestehend aus acht \gls{bit}. Die Binärzahl \texttt{11111111} entspricht der Dezimalzahl \(255\). Bei Erhöhung um eins bekommt die Binärzahl ein neuntes Zeichen und sieht wie folgt aus: \texttt{100000000}. In diesem Fall sind nur die letzten acht \glspl{bit} von Bedeutung. Diese bleiben bei einer Erhöhung der Zahl um die Dezimalzahl \(256\) gleich. Dadurch lässt sich das Problem der bereits zu hohen Anzahl gedruckter Zeichen eifach lösen, indem statt der ursprünglichen Zahl die nächsthöhere Zahl in Schritten von 256 verwendet wird. 
	
	\item Bei Ausführung des Programms wird dieses Verfahren insgesamt viermal angewendet und dadurch eine ganze Speicheradresse an die Adresse der \texttt{test\_val} geschrieben. Eine Veränderung der nächsten drei Bytes hinter der \texttt{test\_val}-Variable lässt sich nicht vermeiden, dies ist aber nicht weiter störend. 
\end{enumerate}

\subsection{Network Sniffing}\label{subsec:networksniffing}
Network Sniffing beschreibt das Abfangen und Auslesen von an andere Geräte adressierten Datenpaketen in einem Netzwerk. Dazu wird ein Network Sniffer verwendet. Network Sniffers analysieren den Datenverkehr in einem Netzwerk. Die Verwendung ist erlaubt und kann Netzwerkadministratoren helfen, die Effizienz eines Netzwerkes durch gezielte Veränderung bestimmter Parameter zu verbessern. Da sie das Auslesen von fremden Daten ermöglichen, werden sie aber oft zu kriminellen Zwecken gebraucht.
\subsubsection{Allgemeine Funktionsweise}
Die Attacke ist vor Allem bei älteren Netzwerken effektiv. Diese greifen teilweise auf Hubs zurück. Hubs sind Datenverteiler, die keine direkten Verbindungen zwischen Netzwerkgeräten aufbauen, sondern alle Datenpakete an alle im Netzwerk befindlichen Geräte senden. Dabei vertrauen sie darauf, dass nur der eigentliche Empfänger die Daten ausliest. In der Standardkonfiguration ignorieren Betriebssysteme Datenpakete, die an einen anderen Empfänger gerichtet sind, dies lässt sich in den meisten Fällen jedoch leicht ändern. Die dazu benötigten Schritte variieren zwischen verschiedenen Betriebssystem. Die Installation eines Raw Sockets als Network Sniffer ermöglicht das Mitlesen von Datenpaketen. Eine bekannte Software hierfür ist Wireshark. Nach Empfang der Datenpaketen können diese oft, sofern keine verschlüsselte Kommunikation verwendet wird, bis auf Applikationsebene entpackt werden. Dabei werden unter Umständen sensible Daten wie Passwörter offengelegt, die der Angreifer für weitere Angriffe nutzen kann. 
\subsubsection{Abwehrmechanismen}
Verschiedene Sicherheitssysteme erschweren diese Art von Attacke. Die wichtigsten sind folgende zwei:
\begin{itemize}
	\item \textbf{Verschlüsselung}: Während Verschlüsselung der Datenpakete zwar den unerwünschten Empfang nicht verhindert, macht es diese für den Angreifer, sofern er nicht im Besitzt des Schlüssels ist, unbrauchbar. Dazu kann ein \gls{vpn} verwendet werden.
	\paragraph{VPN}
	Ein \gls{vpn} verschlüsselt die Kommunikation zwischen zwei Endpunkten. Daten werden beim Benutzer verschlüsselt und erst beim \gls{vpn}-Server wieder entschlüsselt. Der Schlüsselaustausch erfolgt beim Verbindungsaufbau. Endgeräten wird eine neue, interne \gls{ip}-Adresse zugewiesen. Dies ermöglicht die Verschleierung des Aufenthaltsortes des Benutzers, da seine Datenpakete vom \gls{vpn}-Server ausgehen zu scheinen. So kann unter anderem auf örtlich gesperrte Inhalte im Internet zugegriffen werden.~\cite{BSIWasis:online}
	\item \textbf{Antivirensoftware}: Oft besitzen Antivirensoftware Systeme zur Erkennung von Netzwerkanomalien. Bei Erkennung einer Unregelmässigkeit wird das System analysiert und möglicherweise vom Netzwerk getrennt.
\end{itemize}
\subsubsection{Konkretes Beispiel}
\textit{Dieses Beispiel wurde vom Verfasser dieser Arbeit konzipiert und dient der Veranschaulichung. Es wird ausdrücklich darauf hingewiesen, dass diese Attacke ohne Zustimmung aller involvierten Parteien illegal ist und strafrechtliche Konsequenzen davontragen kann.}

Voraussetzung dieser Attacke ist ein Netzwerk, dass zur Datenverteilung Hubs einsetzt. In diesem Netzwerk müssen Geräte die veraltete, unverschlüsselte Version des \gls{pop3}-Mail-Protokolls verwenden. Diese Situation ist in kleinen Unternehmen mit alter \gls{it}-Infrastruktur denkbar.  Ziel der Attacke ist es, Zugriff auf den Mail-Server eines Benutzers zu erhalten. Zusätzlich zu obig genannten Voraussetzungen muss der Angreifer Zugriff auf das Netzwerk besitzen und im Besitzt eines Network Sniffers sein. In diesem Beispiel wird das Programm Wireshark benutzt, das unter folgendem Link kostenfrei heruntergeladen werden kann: \url{https://www.wireshark.org/}. Folgende Schritte sind nötig:

\begin{enumerate}
	\item Beim Start des Programms Wireshark muss eine Schnittstelle gewählt werden. Diese hängt von der Verbindungsart des Angreifers zum Netzwerk ab. Handelt es sich um eine \gls{wlan}-Verbindung, muss in meinem Fall die Schnittstelle \gls{wlan} gewählt werden, je nach Netzwerk-Hardware kann die Namensgebung aber unterschiedlich ausfallen.
	\item Nachdem die Aufzeichnung der Netzwerkverkehrs gestartet wurde, müssen die erhaltenen Daten nach dem \gls{pop3}-Mail-Protokoll gefiltert werden. Die unverschlüsselte \gls{pop3}-Kommunikation erfolgt auf Port 110. In Wireshark wird deshalb der Filter \texttt{tcp.port == 110} festgelegt. Alle angezeigten Datenpakete beziehen sich dann auf \gls{pop3} basierte Kommunikation.
	\item Der Netzwerkverkehr muss nun so lange aufgezeichnet werden, bis ein Benutzer sich auf den Mail-Server einloggt. Beim Login-Vorgang werden die Benutzerdaten in plaintext, also ohne Verschlüsselung, an den Mail-Server gesendet. Sobald dieses Datenpakete gefunden wurde, kann der Angreifer mithilfe der Benutzerdaten selbst Anfragen an den Mail-Server des Opfers stellen. Damit ist er im Besitz von Lese- und Schreibrechten über den Mail-Account des Opfers und kann somit erhaltene Mails lesen oder selbst Mails verfassen.
\end{enumerate}

\subsection{Man-in-the-Middle}
Normalerweise erfolgt die Kommunikation zwischen zwei Geräten in einem Netzwerk auf direktem Weg. Ziel einer \gls{mitm}-Attacke ist es deshalb, sich zwischen eine direkte Verbindung zu setzten und so Zugriff auf die gesendeten Datenpakete zu erlangen. Technisch gesehen handelt es sich dabei um aktives Network Sniffing und könnte so Kapitel \ref{subsec:networksniffing} untergeordnet werden, da die Vorgehensweisen aber sehr unterschiedlich ausfallen, wird die \gls{mitm}-Attacke in dieser Arbeit als eigenes Kapitel behandelt. Bei einer Kommunikation zwischen \texttt{A} und \texttt{B} gibt der Angreifer \texttt{A} vor, \texttt{B} zu sein und \texttt{B} vor, \texttt{A} zu sein. Während \texttt{A} und \texttt{B} weiter glauben, Datenpakte an ihren Kommunikationspartner zu senden, senden sie diese dem Angreifer. Dieser kann so etwa an sensible Informationen gelangen oder durch gezielte Veränderung der Datenpakete bestimmte Reaktionen bei den Empfängern hervorrufen.

\subsubsection{Allgemeine Funktionsweise}
Zur Einrichtung einer \gls{mitm}-Attacke wird zuerst Network Sniffing \ref{subsec:networksniffing} eingesetzt, um eine bestehende Verbindung zwischen zwei Geräten \texttt{A} und \texttt{B} zu erkennen. Danach kommt eine Technik namens \gls{arp}-Spoofing zum Zug. 

\paragraph{ARP-Spoofing}
\gls{arp} ist ein simples Netzwerkprotokoll, dass wie bereits in Kapitel \ref{subsubsec:osimodell} \gls{ip}- in \gls{mac}-Adressen umwandelt. Da das Protokoll auf Datenprotokollierung verzichtet, akzeptiert ein Gerät \gls{arp}-Antworten, ohne eine \gls{arp}-Anfrage gestellt zu haben. Dies kann ein Angreifer ausnutzen, um die Kommunikation von Geräten mit gefälschten \gls{arp}-Antworten umzulenken. 

Bei einer \gls{mitm}-Attacke sendet der Angreifer folgende \gls{arp}-Antworten:
\begin{itemize}
	\item An A: ``Die \gls{mac}-Adresse von \texttt{B} ist [\gls{mac}-Adresse des Angreifers].''
	\item An B: ``Die \gls{mac}-Adresse von \texttt{A} ist [\gls{mac}-Adresse des Angreifers].''
\end{itemize}

Dadurch werden die beiden Kommunikationspartner getäuscht und senden ihre Datenpakte an den Angreifer, anstatt direkt zu kommunizieren. Der Angreifer erhält Zugriff auf die gesendeten Datenpakete und kann diese bei unverschlüsselter Kommunikation bis auf Applikationsebene entpacken. Dabei werden unter Umständen sensible Daten wie Passwörter offengelegt. Um die Täuschung aufrecht zu erhalten, muss der Angreifer die \gls{arp}-Antworten wiederholte senden, da immer wieder echte \gls{arp}-Anfragen zur Verifikation zu erwarten sind. 

Damit die Kommunikation fortzusetzen, leitet der Angreifer die Datenpakte nach Empfang weiter. Die Weiterleitung ermöglicht dem Angreifer weiter Möglichkeiten. Da die Kommunikationspartner der Kommunikation weiterhin vertrauen, können beim Empfänger durch gezielte Veränderung der in den Datenpaketen enthaltenen Daten bestimmte Reaktionen hervorgerufen werden. Die Datenpakete müssen aber auf jeden Fall so modifiziert werden, dass die Kommunikationspartner keinen Verdacht schöpfen. Wird beispielsweise die \gls{mac}-Adresse des Angreifer im Datenpaket verwendet, muss diese vor der Weiterleitung mit der \gls{mac}-Adresse des finalen Empfängers ersetzt werden. 


\subsubsection{Abwehrmechanismen}
Da beide Attacken netzwerkbasiert sind, fallen die Sicherheitsysteme ähnlich aus wie beim Network Sniffing (Kapitel \ref{subsec:networksniffing}). Zusätzlich zur Verschlüsselung und Systeme zur Erkennung von Netzwerkanomalien kommt folgender Aspekt hinzu:

\begin{itemize}
	\item \textbf{Statische \gls{arp}-Einträge}: Ist eine Verbindung zwischen zwei Geräten einmal etabliert, können sie einen statischen \gls{arp}-Eintrag vornehmen. Dadurch wird die Zuordnung von \gls{ip}- und \gls{mac}-Adresse fixiert und neue, möglicherweise gefälschte \gls{arp}-Antworten ignoriert. 
\end{itemize}

\subsection{Denial of Service}

\paragraph{Nachrichtentyp}

\paragraph{Verstärkungsmethoden}

\subsubsection{Allgemeine Funktionsweise}

\subsubsection{Abwehrmechanismen}


\subsection{Erklärung weiterer Begriffe}
\begin{itemize}
	\item Phishing
	\item Passwort-Attacken
	\item Ransomware
	\item Viren
	\item Würmer
	\item Trojaner
	\item Malware
\end{itemize}


\section{Analyse bekannter Hackerangriffen}

\subsection{Russische Einflussnahme auf die Präsidentschaftswahlen (2016)}

\subsection{Angriff auf das ukrainische Stromnetz (2015)}

\subsection{WannaCry Ransomware (2017)}


\section{Das Dark Web}

\subsection{Grundlagen}

\subsection{Zugangsmechanismen und Tools}

\subsection{Sicherheitsrisiken}

\section{Diskussion}
was ist rausgekommen?

\section{Ausblick}
was hätte man noch machen können? Rechtliche Aspekte, Analyse moderner Hacking-Attacken, Dark Web


\appendix
\newpage
\renewcommand{\thesubsection}{\Alph{subsection}}
\counterwithin{figure}{subsection}
\counterwithin{table}{subsection}
\pagebreak

\section{Appendix}
\subsection{Beispiele aus ``Hacking - The Art of Exploitation''}\label{subsec:beispiele}
Einige Beispiele des Buches ``Hacking - The Art of Exploitation''~\cite{erickson2008hacking} wurden direkt in diese Arbeit übernommen. Diese sind so gekennzeichnet. Die Beispiele dienen als praktische Veranschaulichung der theoretischen Beschreibung der Hacking-Attacken. Sie können auf eigene Verantwortung nachgestellt werden. Der Autor verweist ausdrücklich darauf hin, dass Attacken dieser Art ohne Zustimmung aller involvierten Parteien unter Umständen illegal und bestrafbar sind. Zur Durchführung wird ein 32bit Linux System ohne den unter \textbf{Abwehrmechanismen} aufgelisteten Sicherheitssystemen benötigt. Unter diesem Github-Link finden sich die benötigten Programme und ein \gls{iso}-Abbild der originalen LiveCD, die zum Buch ``Hacking - The Art of Exploitation''~\cite{erickson2008hacking} mitgeliefert wurde: \url{https://github.com/corst10/Maturaarbeit-Hacking-Cybersicherheit-Corsin-Streit/tree/main/code_files}. Das \gls{iso}-Abbild kann mit einer Virtualisierungssoftware wie Oracle VirtualBox virtualisiert werden. Da das System aus dem Jahr 2008 stammt und dementsprechend veraltete Sicherheitssysteme besitzt, ist ihm nur mit äusserster Vorsicht Internetzugriff zu gewähren. Die wichtigsten Programme sind im Folgenden abgedruckt.



\newpage
\printbibliography
\listoffigures
\listoftables
\printglossaries
\end{document}
